var data = {"bug_cases": {"BugType": "NULL pointer dereference", "Severity": 12, "CaseList": [{"HashID": "b27ec900ce24ed2c380b43a5ee0c9e34", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "ca1bcbeb340dcd3309559e910e85ed73.c", "FileName": "crypto/stack/stack.c", "Line": 289, "Tip": "Return <b>null</b> to caller", "SrcLines": ["void *OPENSSL_sk_value(const OPENSSL_STACK *st, int i)", "{", "    if (st == NULL || i < 0 || i >= st->num)", "        return NULL;", "    return (void *)st->data[i];", "}", "", "void *OPENSSL_sk_set(OPENSSL_STACK *st, int i, const void *data)", "{", "    if (st == NULL || i < 0 || i >= st->num)"], "SrcStart": 284}, {"FileMD5": "a6dbcec852bd4f0358827aa456afd197.h", "FileName": "include/openssl/conf.h", "Line": 31, "Tip": "Return the return value of function <b>OPENSSL_sk_value</b> to caller", "SrcLines": ["    char *section;", "    char *name;", "    char *value;", "} CONF_VALUE;", "", "DEFINE_STACK_OF(CONF_VALUE)", "DEFINE_LHASH_OF(CONF_VALUE);", "", "struct conf_st;", "struct conf_method_st;"], "SrcStart": 26}, {"FileMD5": "6edef3b9caa8cf6441405202373a0d06.c", "FileName": "crypto/conf/conf_api.c", "Line": 178, "Tip": "Function <b>sk_CONF_VALUE_value</b> executes and stores the return value to <b>vv</b> (<b>vv</b> can be null)", "SrcLines": ["    if (a->name != NULL)", "        return;", "", "    sk = (STACK_OF(CONF_VALUE) *)a->value;", "    for (i = sk_CONF_VALUE_num(sk) - 1; i >= 0; i--) {", "        vv = sk_CONF_VALUE_value(sk, i);", "        OPENSSL_free(vv->value);", "        OPENSSL_free(vv->name);", "        OPENSSL_free(vv);", "    }"], "SrcStart": 173}, {"FileMD5": "6edef3b9caa8cf6441405202373a0d06.c", "FileName": "crypto/conf/conf_api.c", "Line": 180, "Tip": "Load value from <b>vv-&gt;name</b>", "SrcLines": ["", "    sk = (STACK_OF(CONF_VALUE) *)a->value;", "    for (i = sk_CONF_VALUE_num(sk) - 1; i >= 0; i--) {", "        vv = sk_CONF_VALUE_value(sk, i);", "        OPENSSL_free(vv->value);", "        OPENSSL_free(vv->name);", "        OPENSSL_free(vv);", "    }", "    sk_CONF_VALUE_free(sk);", "    OPENSSL_free(a->section);"], "SrcStart": 175}], "Review": 80, "Time": 1630075188000, "DocID": "PE0001", "File": "crypto/conf/conf_api.c", "Line": 180}, {"HashID": "f37f63586bfbb74ba4e73353197ace2c", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "2f869148a38450313f6d48829e23d095.c", "FileName": "crypto/conf/conf_lib.c", "Line": 127, "Tip": "<b>null</b> is used as the 1st parameter in function <b>NCONF_get_number_e</b>", "SrcLines": ["{", "    int status;", "    long result = 0;", "", "    if (conf == NULL) {", "        status = NCONF_get_number_e(NULL, group, name, &result);", "    } else {", "        CONF ctmp;", "        CONF_set_nconf(&ctmp, conf);", "        status = NCONF_get_number_e(&ctmp, group, name, &result);"], "SrcStart": 122}, {"FileMD5": "2f869148a38450313f6d48829e23d095.c", "FileName": "crypto/conf/conf_lib.c", "Line": 295, "Tip": "Load value from <b>conf-&gt;meth</b>", "SrcLines": ["    str = NCONF_get_string(conf, group, name);", "", "    if (str == NULL)", "        return 0;", "", "    for (*result = 0; conf->meth->is_number(conf, *str);) {", "        *result = (*result) * 10 + conf->meth->to_int(conf, *str);", "        str++;", "    }", ""], "SrcStart": 290}], "Review": 80, "Time": 1630075188000, "DocID": "PE0001", "File": "crypto/conf/conf_lib.c", "Line": 295}, {"HashID": "6a9e8ad35cc4c720148954ad58dd7187", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "ca1bcbeb340dcd3309559e910e85ed73.c", "FileName": "crypto/stack/stack.c", "Line": 289, "Tip": "Return <b>null</b> to caller", "SrcLines": ["void *OPENSSL_sk_value(const OPENSSL_STACK *st, int i)", "{", "    if (st == NULL || i < 0 || i >= st->num)", "        return NULL;", "    return (void *)st->data[i];", "}", "", "void *OPENSSL_sk_set(OPENSSL_STACK *st, int i, const void *data)", "{", "    if (st == NULL || i < 0 || i >= st->num)"], "SrcStart": 284}, {"FileMD5": "a6dbcec852bd4f0358827aa456afd197.h", "FileName": "include/openssl/conf.h", "Line": 56, "Tip": "Return the return value of function <b>OPENSSL_sk_value</b> to caller", "SrcLines": ["/* Module definitions */", "", "typedef struct conf_imodule_st CONF_IMODULE;", "typedef struct conf_module_st CONF_MODULE;", "", "DEFINE_STACK_OF(CONF_MODULE)", "DEFINE_STACK_OF(CONF_IMODULE)", "", "/* DSO module function typedefs */", "typedef int conf_init_func (CONF_IMODULE *md, const CONF *cnf);"], "SrcStart": 51}, {"FileMD5": "b979c5fe3523dcc0aa70c5d461f9bf2b.c", "FileName": "crypto/conf/conf_mod.c", "Line": 361, "Tip": "Function <b>sk_CONF_MODULE_value</b> executes and stores the return value to <b>md</b> (<b>md</b> can be null)", "SrcLines": ["    int i;", "    CONF_MODULE *md;", "    CONF_modules_finish();", "    /* unload modules in reverse order */", "    for (i = sk_CONF_MODULE_num(supported_modules) - 1; i >= 0; i--) {", "        md = sk_CONF_MODULE_value(supported_modules, i);", "        /* If static or in use and 'all' not set ignore it */", "        if (((md->links > 0) || !md->dso) && !all)", "            continue;", "        /* Since we're working in reverse this is OK */"], "SrcStart": 356}, {"FileMD5": "b979c5fe3523dcc0aa70c5d461f9bf2b.c", "FileName": "crypto/conf/conf_mod.c", "Line": 363, "Tip": "Load value from <b>md-&gt;links</b>", "SrcLines": ["    CONF_modules_finish();", "    /* unload modules in reverse order */", "    for (i = sk_CONF_MODULE_num(supported_modules) - 1; i >= 0; i--) {", "        md = sk_CONF_MODULE_value(supported_modules, i);", "        /* If static or in use and 'all' not set ignore it */", "        if (((md->links > 0) || !md->dso) && !all)", "            continue;", "        /* Since we're working in reverse this is OK */", "        (void)sk_CONF_MODULE_delete(supported_modules, i);", "        module_free(md);"], "SrcStart": 358}], "Review": 80, "Time": 1630075188000, "DocID": "PE0001", "File": "crypto/conf/conf_mod.c", "Line": 363}, {"HashID": "ae21bfdedaf05ad4e86f18605ed89da5", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "cd7ba017f5f908e70da2115c23e66751.c", "FileName": "crypto/cms/cms_kari.c", "Line": 206, "Tip": "<b>null</b> is used as the 2nd parameter in function <b>EVP_CipherUpdate</b>", "SrcLines": ["        goto err;", "    /* Set KEK in context */", "    if (!EVP_CipherInit_ex(kari->ctx, NULL, NULL, kek, NULL, enc))", "        goto err;", "    /* obtain output length of ciphered key */", "    if (!EVP_CipherUpdate(kari->ctx, NULL, &outlen, in, inlen))", "        goto err;", "    out = OPENSSL_malloc(outlen);", "    if (out == NULL)", "        goto err;"], "SrcStart": 201}, {"FileMD5": "903a258fe3914a31eb9c0f93ffe55158.c", "FileName": "crypto/evp/evp_enc.c", "Line": 214, "Tip": "<b>out</b> is used as the 2nd parameter in function <b>EVP_DecryptUpdate</b> (<b>out</b> can be null)", "SrcLines": ["                     const unsigned char *in, int inl)", "{", "    if (ctx->encrypt)", "        return EVP_EncryptUpdate(ctx, out, outl, in, inl);", "    else", "        return EVP_DecryptUpdate(ctx, out, outl, in, inl);", "}", "", "int EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)", "{"], "SrcStart": 209}, {"FileMD5": "903a258fe3914a31eb9c0f93ffe55158.c", "FileName": "crypto/evp/evp_enc.c", "Line": 465, "Tip": "Copy data to <b>out</b> (<b>out</b> can be null)", "SrcLines": ["        if (((PTRDIFF_T)out == (PTRDIFF_T)in)", "            || is_partially_overlapping(out, in, b)) {", "            EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_PARTIALLY_OVERLAPPING);", "            return 0;", "        }", "        memcpy(out, ctx->final, b);", "        out += b;", "        fix_len = 1;", "    } else", "        fix_len = 0;"], "SrcStart": 460}], "Review": 80, "Time": 1630075188000, "DocID": "PE0001", "File": "crypto/evp/evp_enc.c", "Line": 465}, {"HashID": "18ca4c945c62c5b0de5d2afb2a8db73d", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "cd7ba017f5f908e70da2115c23e66751.c", "FileName": "crypto/cms/cms_kari.c", "Line": 206, "Tip": "<b>null</b> is used as the 2nd parameter in function <b>EVP_CipherUpdate</b>", "SrcLines": ["        goto err;", "    /* Set KEK in context */", "    if (!EVP_CipherInit_ex(kari->ctx, NULL, NULL, kek, NULL, enc))", "        goto err;", "    /* obtain output length of ciphered key */", "    if (!EVP_CipherUpdate(kari->ctx, NULL, &outlen, in, inlen))", "        goto err;", "    out = OPENSSL_malloc(outlen);", "    if (out == NULL)", "        goto err;"], "SrcStart": 201}, {"FileMD5": "903a258fe3914a31eb9c0f93ffe55158.c", "FileName": "crypto/evp/evp_enc.c", "Line": 214, "Tip": "<b>out</b> is used as the 2nd parameter in function <b>EVP_DecryptUpdate</b> (<b>out</b> can be null)", "SrcLines": ["                     const unsigned char *in, int inl)", "{", "    if (ctx->encrypt)", "        return EVP_EncryptUpdate(ctx, out, outl, in, inl);", "    else", "        return EVP_DecryptUpdate(ctx, out, outl, in, inl);", "}", "", "int EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)", "{"], "SrcStart": 209}, {"FileMD5": "903a258fe3914a31eb9c0f93ffe55158.c", "FileName": "crypto/evp/evp_enc.c", "Line": 460, "Tip": "Select the false branch at this point (<b>is_partially_overlapping(out,in,b)!=0</b> is false)", "SrcLines": ["", "    OPENSSL_assert(b <= sizeof(ctx->final));", "", "    if (ctx->final_used) {", "        /* see comment about PTRDIFF_T comparison above */", "        if (((PTRDIFF_T)out == (PTRDIFF_T)in)", "            || is_partially_overlapping(out, in, b)) {", "            EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_PARTIALLY_OVERLAPPING);", "            return 0;", "        }"], "SrcStart": 455}, {"FileMD5": "903a258fe3914a31eb9c0f93ffe55158.c", "FileName": "crypto/evp/evp_enc.c", "Line": 481, "Tip": "Copy data from <b>&amp;(out[outl])</b> (<b>&amp;(out[outl])</b> can be null)", "SrcLines": ["     * copy of this last block", "     */", "    if (b > 1 && !ctx->buf_len) {", "        *outl -= b;", "        ctx->final_used = 1;", "        memcpy(ctx->final, &out[*outl], b);", "    } else", "        ctx->final_used = 0;", "", "    if (fix_len)"], "SrcStart": 476}], "Review": 80, "Time": 1630075188000, "DocID": "PE0001", "File": "crypto/evp/evp_enc.c", "Line": 481}, {"HashID": "897f37b342a389441d2ba27498e0f76b", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "cd7ba017f5f908e70da2115c23e66751.c", "FileName": "crypto/cms/cms_kari.c", "Line": 179, "Tip": "Return <b>null</b> to caller", "SrcLines": ["EVP_CIPHER_CTX *CMS_RecipientInfo_kari_get0_ctx(CMS_RecipientInfo *ri)", "{", "    if (ri->type == CMS_RECIPINFO_AGREE)", "        return ri->d.kari->ctx;", "    return NULL;", "}", "", "/*", " * Derive KEK and decrypt/encrypt with it to produce either the original CEK", " * or the encrypted CEK."], "SrcStart": 174}, {"FileMD5": "58ac689eedc31065c79a74c9dac927b5.c", "FileName": "crypto/ec/ec_ameth.c", "Line": 832, "Tip": "Function <b>CMS_RecipientInfo_kari_get0_ctx</b> executes and stores the return value to <b>ctx</b> (<b>ctx</b> can be null)", "SrcLines": ["    /* Lookup NID for KDF+cofactor+digest */", "", "    if (!OBJ_find_sigid_by_algs(&kdf_nid, EVP_MD_type(kdf_md), ecdh_nid))", "        goto err;", "    /* Get wrap NID */", "    ctx = CMS_RecipientInfo_kari_get0_ctx(ri);", "    wrap_nid = EVP_CIPHER_CTX_type(ctx);", "    keylen = EVP_CIPHER_CTX_key_length(ctx);", "", "    /* Package wrap algorithm in an AlgorithmIdentifier */"], "SrcStart": 827}, {"FileMD5": "58ac689eedc31065c79a74c9dac927b5.c", "FileName": "crypto/ec/ec_ameth.c", "Line": 833, "Tip": "<b>ctx</b> is used as the 1st parameter in function <b>EVP_CIPHER_CTX_cipher</b> (<b>ctx</b> can be null)", "SrcLines": ["", "    if (!OBJ_find_sigid_by_algs(&kdf_nid, EVP_MD_type(kdf_md), ecdh_nid))", "        goto err;", "    /* Get wrap NID */", "    ctx = CMS_RecipientInfo_kari_get0_ctx(ri);", "    wrap_nid = EVP_CIPHER_CTX_type(ctx);", "    keylen = EVP_CIPHER_CTX_key_length(ctx);", "", "    /* Package wrap algorithm in an AlgorithmIdentifier */", ""], "SrcStart": 828}, {"FileMD5": "72ecc22958d0d8b5932180aae1aff510.c", "FileName": "crypto/evp/evp_lib.c", "Line": 188, "Tip": "Load value from <b>ctx-&gt;cipher</b>", "SrcLines": ["    return ctx->cipher->do_cipher(ctx, out, in, inl);", "}", "", "const EVP_CIPHER *EVP_CIPHER_CTX_cipher(const EVP_CIPHER_CTX *ctx)", "{", "    return ctx->cipher;", "}", "", "int EVP_CIPHER_CTX_encrypting(const EVP_CIPHER_CTX *ctx)", "{"], "SrcStart": 183}], "Review": 80, "Time": 1630075188000, "DocID": "PE0001", "File": "crypto/evp/evp_lib.c", "Line": 188}, {"HashID": "b5c9938c796efa9db0ae5a3f9cfe2980", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "72ecc22958d0d8b5932180aae1aff510.c", "FileName": "crypto/evp/evp_lib.c", "Line": 444, "Tip": "Return <b>null</b> to caller", "SrcLines": ["const EVP_MD *EVP_MD_CTX_md(const EVP_MD_CTX *ctx)", "{", "    if (!ctx)", "        return NULL;", "    return ctx->digest;", "}", "", "EVP_PKEY_CTX *EVP_MD_CTX_pkey_ctx(const EVP_MD_CTX *ctx)", "{", "    return ctx->pctx;"], "SrcStart": 439}, {"FileMD5": "ab961d30e4b25b4019835ddf78622456.c", "FileName": "crypto/cms/cms_lib.c", "Line": 328, "Tip": "The return value of function <b>EVP_MD_CTX_md</b> is used as the 1st parameter in function <b>EVP_MD_type</b> (the return value of function <b>EVP_MD_CTX_md</b> can be null)", "SrcLines": ["            CMSerr(CMS_F_CMS_DIGESTALGORITHM_FIND_CTX,", "                   CMS_R_NO_MATCHING_DIGEST);", "            return 0;", "        }", "        BIO_get_md_ctx(chain, &mtmp);", "        if (EVP_MD_CTX_type(mtmp) == nid", "            /*", "             * Workaround for broken implementations that use signature", "             * algorithm OID instead of digest.", "             */"], "SrcStart": 323}, {"FileMD5": "72ecc22958d0d8b5932180aae1aff510.c", "FileName": "crypto/evp/evp_lib.c", "Line": 293, "Tip": "Load value from <b>md-&gt;type</b>", "SrcLines": ["    return md->block_size;", "}", "", "int EVP_MD_type(const EVP_MD *md)", "{", "    return md->type;", "}", "", "int EVP_MD_pkey_type(const EVP_MD *md)", "{"], "SrcStart": 288}], "Review": 80, "Time": 1630075188000, "DocID": "PE0001", "File": "crypto/evp/evp_lib.c", "Line": 293}, {"HashID": "a773321234f1b00e7cd05e8efe19b7b0", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "72ecc22958d0d8b5932180aae1aff510.c", "FileName": "crypto/evp/evp_lib.c", "Line": 444, "Tip": "Return <b>null</b> to caller", "SrcLines": ["const EVP_MD *EVP_MD_CTX_md(const EVP_MD_CTX *ctx)", "{", "    if (!ctx)", "        return NULL;", "    return ctx->digest;", "}", "", "EVP_PKEY_CTX *EVP_MD_CTX_pkey_ctx(const EVP_MD_CTX *ctx)", "{", "    return ctx->pctx;"], "SrcStart": 439}, {"FileMD5": "ab961d30e4b25b4019835ddf78622456.c", "FileName": "crypto/cms/cms_lib.c", "Line": 333, "Tip": "The return value of function <b>EVP_MD_CTX_md</b> is used as the 1st parameter in function <b>EVP_MD_pkey_type</b> (the return value of function <b>EVP_MD_CTX_md</b> can be null)", "SrcLines": ["        if (EVP_MD_CTX_type(mtmp) == nid", "            /*", "             * Workaround for broken implementations that use signature", "             * algorithm OID instead of digest.", "             */", "            || EVP_MD_pkey_type(EVP_MD_CTX_md(mtmp)) == nid)", "            return EVP_MD_CTX_copy_ex(mctx, mtmp);", "        chain = BIO_next(chain);", "    }", "}"], "SrcStart": 328}, {"FileMD5": "72ecc22958d0d8b5932180aae1aff510.c", "FileName": "crypto/evp/evp_lib.c", "Line": 298, "Tip": "Load value from <b>md-&gt;pkey_type</b>", "SrcLines": ["    return md->type;", "}", "", "int EVP_MD_pkey_type(const EVP_MD *md)", "{", "    return md->pkey_type;", "}", "", "int EVP_MD_size(const EVP_MD *md)", "{"], "SrcStart": 293}], "Review": 80, "Time": 1630075188000, "DocID": "PE0001", "File": "crypto/evp/evp_lib.c", "Line": 298}, {"HashID": "cda4805a0daeae8eff2cfb906970ef9e", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "e668f539492f57d3258c61cfac761d59.c", "FileName": "crypto/x509/x_pubkey.c", "Line": 167, "Tip": "Return <b>null</b> to caller", "SrcLines": ["        X509err(X509_F_X509_PUBKEY_GET0, ERR_R_INTERNAL_ERROR);", "        EVP_PKEY_free(ret);", "    }", "", "    return NULL;", "}", "", "EVP_PKEY *X509_PUBKEY_get(X509_PUBKEY *key)", "{", "    EVP_PKEY *ret = X509_PUBKEY_get0(key);"], "SrcStart": 162}, {"FileMD5": "c3d35333c160e4c36abbd345287c2c1d.c", "FileName": "crypto/x509/x509_cmp.c", "Line": 269, "Tip": "Function <b>X509_PUBKEY_get0</b> executes and returns", "SrcLines": ["", "EVP_PKEY *X509_get0_pubkey(const X509 *x)", "{", "    if (x == NULL)", "        return NULL;", "    return X509_PUBKEY_get0(x->cert_info.key);", "}", "", "EVP_PKEY *X509_get_pubkey(X509 *x)", "{"], "SrcStart": 264}, {"FileMD5": "c3d35333c160e4c36abbd345287c2c1d.c", "FileName": "crypto/x509/x509_cmp.c", "Line": 270, "Tip": "Return the return value of function <b>X509_PUBKEY_get0</b> to caller (The return value can be null)", "SrcLines": ["EVP_PKEY *X509_get0_pubkey(const X509 *x)", "{", "    if (x == NULL)", "        return NULL;", "    return X509_PUBKEY_get0(x->cert_info.key);", "}", "", "EVP_PKEY *X509_get_pubkey(X509 *x)", "{", "    if (x == NULL)"], "SrcStart": 265}, {"FileMD5": "59a9b59273169ca11c8c5ce21773f8c5.c", "FileName": "crypto/x509/x509_vfy.c", "Line": 1903, "Tip": "Function <b>X509_get0_pubkey</b> executes and stores the return value to <b>ktmp2</b> (<b>ktmp2</b> can be null)", "SrcLines": ["        return 0;", "    }", "", "    /* first, populate the other certs */", "    for (j = i - 1; j >= 0; j--) {", "        ktmp2 = X509_get0_pubkey(sk_X509_value(chain, j));", "        EVP_PKEY_copy_parameters(ktmp2, ktmp);", "    }", "", "    if (pkey != NULL)"], "SrcStart": 1898}, {"FileMD5": "59a9b59273169ca11c8c5ce21773f8c5.c", "FileName": "crypto/x509/x509_vfy.c", "Line": 1904, "Tip": "<b>ktmp2</b> is used as the 1st parameter in function <b>EVP_PKEY_copy_parameters</b> (<b>ktmp2</b> can be null)", "SrcLines": ["    }", "", "    /* first, populate the other certs */", "    for (j = i - 1; j >= 0; j--) {", "        ktmp2 = X509_get0_pubkey(sk_X509_value(chain, j));", "        EVP_PKEY_copy_parameters(ktmp2, ktmp);", "    }", "", "    if (pkey != NULL)", "        EVP_PKEY_copy_parameters(pkey, ktmp);"], "SrcStart": 1899}, {"FileMD5": "c865f8484c4fad9d0e264bd9cb31a357.c", "FileName": "crypto/evp/p_lib.c", "Line": 75, "Tip": "Load value from <b>to-&gt;type</b>", "SrcLines": ["    return (0);", "}", "", "int EVP_PKEY_copy_parameters(EVP_PKEY *to, const EVP_PKEY *from)", "{", "    if (to->type == EVP_PKEY_NONE) {", "        if (EVP_PKEY_set_type(to, from->type) == 0)", "            return 0;", "    } else if (to->type != from->type) {", "        EVPerr(EVP_F_EVP_PKEY_COPY_PARAMETERS, EVP_R_DIFFERENT_KEY_TYPES);"], "SrcStart": 70}], "Review": 80, "Time": 1630075188000, "DocID": "PE0001", "File": "crypto/evp/p_lib.c", "Line": 75}, {"HashID": "5e91f5ba00b84c28a61ac7a4fd1512a0", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "aa56023a13915a4055ab5c7e22cc2aa4.c", "FileName": "crypto/x509/x509_req.c", "Line": 68, "Tip": "Return <b>null</b> to caller", "SrcLines": ["EVP_PKEY *X509_REQ_get_pubkey(X509_REQ *req)", "{", "    if (req == NULL)", "        return (NULL);", "    return (X509_PUBKEY_get(req->req_info.pubkey));", "}", "", "EVP_PKEY *X509_REQ_get0_pubkey(X509_REQ *req)", "{", "    if (req == NULL)"], "SrcStart": 63}, {"FileMD5": "aa56023a13915a4055ab5c7e22cc2aa4.c", "FileName": "crypto/x509/x509_req.c", "Line": 87, "Tip": "Function <b>X509_REQ_get_pubkey</b> executes and stores the return value to <b>xk</b> (<b>xk</b> can be null)", "SrcLines": ["int X509_REQ_check_private_key(X509_REQ *x, EVP_PKEY *k)", "{", "    EVP_PKEY *xk = NULL;", "    int ok = 0;", "", "    xk = X509_REQ_get_pubkey(x);", "    switch (EVP_PKEY_cmp(xk, k)) {", "    case 1:", "        ok = 1;", "        break;"], "SrcStart": 82}, {"FileMD5": "aa56023a13915a4055ab5c7e22cc2aa4.c", "FileName": "crypto/x509/x509_req.c", "Line": 88, "Tip": "<b>xk</b> is used as the 1st parameter in function <b>EVP_PKEY_cmp</b> (<b>xk</b> can be null)", "SrcLines": ["{", "    EVP_PKEY *xk = NULL;", "    int ok = 0;", "", "    xk = X509_REQ_get_pubkey(x);", "    switch (EVP_PKEY_cmp(xk, k)) {", "    case 1:", "        ok = 1;", "        break;", "    case 0:"], "SrcStart": 83}, {"FileMD5": "c865f8484c4fad9d0e264bd9cb31a357.c", "FileName": "crypto/evp/p_lib.c", "Line": 119, "Tip": "Load value from <b>a-&gt;type</b>", "SrcLines": ["    return -2;", "}", "", "int EVP_PKEY_cmp(const EVP_PKEY *a, const EVP_PKEY *b)", "{", "    if (a->type != b->type)", "        return -1;", "", "    if (a->ameth) {", "        int ret;"], "SrcStart": 114}], "Review": 80, "Time": 1630075188000, "DocID": "PE0001", "File": "crypto/evp/p_lib.c", "Line": 119}]}, "start": 31, "end": 40, "page": 5, "total_pages": 11, "language": "en"}