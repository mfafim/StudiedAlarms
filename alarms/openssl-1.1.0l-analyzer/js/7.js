var data = {"bug_cases": {"BugType": "NULL pointer dereference", "Severity": 12, "CaseList": [{"HashID": "9faa9c3cacf88e7eade17eb5638dc002", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "4a8d92ba2a00923902c67b9d8168c716.c", "FileName": "crypto/x509/x_name.c", "Line": 245, "Tip": "Select the false branch at this point (<b>intname==null</b> is false)", "SrcLines": ["    unsigned char *p;", "    STACK_OF(X509_NAME_ENTRY) *entries = NULL;", "    X509_NAME_ENTRY *entry;", "    int i, set = -1;", "    intname.s = sk_STACK_OF_X509_NAME_ENTRY_new_null();", "    if (!intname.s)", "        goto memerr;", "    for (i = 0; i < sk_X509_NAME_ENTRY_num(a->entries); i++) {", "        entry = sk_X509_NAME_ENTRY_value(a->entries, i);", "        if (entry->set != set) {"], "SrcStart": 240}, {"FileMD5": "4a8d92ba2a00923902c67b9d8168c716.c", "FileName": "crypto/x509/x_name.c", "Line": 249, "Tip": "Select the false branch at this point (<b>entry-&gt;set!=set</b> is false)", "SrcLines": ["    intname.s = sk_STACK_OF_X509_NAME_ENTRY_new_null();", "    if (!intname.s)", "        goto memerr;", "    for (i = 0; i < sk_X509_NAME_ENTRY_num(a->entries); i++) {", "        entry = sk_X509_NAME_ENTRY_value(a->entries, i);", "        if (entry->set != set) {", "            entries = sk_X509_NAME_ENTRY_new_null();", "            if (!entries)", "                goto memerr;", "            if (!sk_STACK_OF_X509_NAME_ENTRY_push(intname.s, entries)) {"], "SrcStart": 244}, {"FileMD5": "4a8d92ba2a00923902c67b9d8168c716.c", "FileName": "crypto/x509/x_name.c", "Line": 259, "Tip": "<b>null</b> is used as the 1st parameter in function <b>sk_X509_NAME_ENTRY_push</b>", "SrcLines": ["                sk_X509_NAME_ENTRY_free(entries);", "                goto memerr;", "            }", "            set = entry->set;", "        }", "        if (!sk_X509_NAME_ENTRY_push(entries, entry))", "            goto memerr;", "    }", "    len = ASN1_item_ex_i2d(&intname.a, NULL,", "                           ASN1_ITEM_rptr(X509_NAME_INTERNAL), -1, -1);"], "SrcStart": 254}, {"FileMD5": "bfba7e508f0613ec8f80e4651fe7d8ae.h", "FileName": "include/openssl/x509.h", "Line": 73, "Tip": "<b>sk</b> is used as the 1st parameter in function <b>OPENSSL_sk_push</b> (<b>sk</b> can be null)", "SrcLines": ["", "typedef struct X509_sig_st X509_SIG;", "", "typedef struct X509_name_entry_st X509_NAME_ENTRY;", "", "DEFINE_STACK_OF(X509_NAME_ENTRY)", "", "DEFINE_STACK_OF(X509_NAME)", "", "# define X509_EX_V_NETSCAPE_HACK         0x8000"], "SrcStart": 68}, {"FileMD5": "ca1bcbeb340dcd3309559e910e85ed73.c", "FileName": "crypto/stack/stack.c", "Line": 221, "Tip": "Load value from <b>st-&gt;num</b>", "SrcLines": ["    return internal_find(st, data, OBJ_BSEARCH_VALUE_ON_NOMATCH);", "}", "", "int OPENSSL_sk_push(OPENSSL_STACK *st, const void *data)", "{", "    return (OPENSSL_sk_insert(st, data, st->num));", "}", "", "int OPENSSL_sk_unshift(OPENSSL_STACK *st, const void *data)", "{"], "SrcStart": 216}], "Review": 80, "Time": 1630075188000, "DocID": "PE0001", "File": "crypto/stack/stack.c", "Line": 221}, {"HashID": "7c1b9f5a349710ec972a16cdc082fa1a", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "ca1bcbeb340dcd3309559e910e85ed73.c", "FileName": "crypto/stack/stack.c", "Line": 289, "Tip": "Return <b>null</b> to caller", "SrcLines": ["void *OPENSSL_sk_value(const OPENSSL_STACK *st, int i)", "{", "    if (st == NULL || i < 0 || i >= st->num)", "        return NULL;", "    return (void *)st->data[i];", "}", "", "void *OPENSSL_sk_set(OPENSSL_STACK *st, int i, const void *data)", "{", "    if (st == NULL || i < 0 || i >= st->num)"], "SrcStart": 284}, {"FileMD5": "7c8c5770a233de69adafe44baba47a58.h", "FileName": "include/openssl/txt_db.h", "Line": 31, "Tip": "Return the return value of function <b>OPENSSL_sk_value</b> to caller", "SrcLines": ["#ifdef  __cplusplus", "extern \"C\" {", "#endif", "", "typedef OPENSSL_STRING *OPENSSL_PSTRING;", "DEFINE_SPECIAL_STACK_OF(OPENSSL_PSTRING, OPENSSL_STRING)", "", "typedef struct txt_db_st {", "    int num_fields;", "    STACK_OF(OPENSSL_PSTRING) *data;"], "SrcStart": 26}, {"FileMD5": "f379dd1747705e4732574924c18ea93f.c", "FileName": "crypto/txt_db/txt_db.c", "Line": 302, "Tip": "Function <b>sk_OPENSSL_PSTRING_value</b> executes and stores the return value to <b>p</b> (<b>p</b> can be null)", "SrcLines": ["        for (i = sk_OPENSSL_PSTRING_num(db->data) - 1; i >= 0; i--) {", "            /*", "             * check if any 'fields' have been allocated from outside of the", "             * initial block", "             */", "            p = sk_OPENSSL_PSTRING_value(db->data, i);", "            max = p[db->num_fields]; /* last address */", "            if (max == NULL) {  /* new row */", "                for (n = 0; n < db->num_fields; n++)", "                    OPENSSL_free(p[n]);"], "SrcStart": 297}, {"FileMD5": "f379dd1747705e4732574924c18ea93f.c", "FileName": "crypto/txt_db/txt_db.c", "Line": 303, "Tip": "Load value from <b>p[db-&gt;num_fields]</b> and assign to <b>max</b>", "SrcLines": ["            /*", "             * check if any 'fields' have been allocated from outside of the", "             * initial block", "             */", "            p = sk_OPENSSL_PSTRING_value(db->data, i);", "            max = p[db->num_fields]; /* last address */", "            if (max == NULL) {  /* new row */", "                for (n = 0; n < db->num_fields; n++)", "                    OPENSSL_free(p[n]);", "            } else {"], "SrcStart": 298}], "Review": 80, "Time": 1630075188000, "DocID": "PE0001", "File": "crypto/txt_db/txt_db.c", "Line": 303}, {"HashID": "8a7d96346c73990e5eb0c24cbae891c6", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "ca1bcbeb340dcd3309559e910e85ed73.c", "FileName": "crypto/stack/stack.c", "Line": 289, "Tip": "Return <b>null</b> to caller", "SrcLines": ["void *OPENSSL_sk_value(const OPENSSL_STACK *st, int i)", "{", "    if (st == NULL || i < 0 || i >= st->num)", "        return NULL;", "    return (void *)st->data[i];", "}", "", "void *OPENSSL_sk_set(OPENSSL_STACK *st, int i, const void *data)", "{", "    if (st == NULL || i < 0 || i >= st->num)"], "SrcStart": 284}, {"FileMD5": "bfba7e508f0613ec8f80e4651fe7d8ae.h", "FileName": "include/openssl/x509.h", "Line": 97, "Tip": "Return the return value of function <b>OPENSSL_sk_value</b> to caller", "SrcLines": ["", "typedef struct x509_cert_aux_st X509_CERT_AUX;", "", "typedef struct x509_cinf_st X509_CINF;", "", "DEFINE_STACK_OF(X509)", "", "/* This is used for a table of trust checking functions */", "", "typedef struct x509_trust_st {"], "SrcStart": 92}, {"FileMD5": "59a9b59273169ca11c8c5ce21773f8c5.c", "FileName": "crypto/x509/x509_vfy.c", "Line": 1220, "Tip": "Function <b>sk_X509_value</b> executes and stores the return value to <b>crl_issuer</b> (<b>crl_issuer</b> can be null)", "SrcLines": ["    int i;", "", "    if (cidx != sk_X509_num(ctx->chain) - 1)", "        cidx++;", "", "    crl_issuer = sk_X509_value(ctx->chain, cidx);", "", "    if (X509_check_akid(crl_issuer, crl->akid) == X509_V_OK) {", "        if (*pcrl_score & CRL_SCORE_ISSUER_NAME) {", "            *pcrl_score |= CRL_SCORE_AKID | CRL_SCORE_ISSUER_CERT;"], "SrcStart": 1215}, {"FileMD5": "59a9b59273169ca11c8c5ce21773f8c5.c", "FileName": "crypto/x509/x509_vfy.c", "Line": 1222, "Tip": "<b>crl_issuer</b> is used as the 1st parameter in function <b>X509_check_akid</b> (<b>crl_issuer</b> can be null)", "SrcLines": ["    if (cidx != sk_X509_num(ctx->chain) - 1)", "        cidx++;", "", "    crl_issuer = sk_X509_value(ctx->chain, cidx);", "", "    if (X509_check_akid(crl_issuer, crl->akid) == X509_V_OK) {", "        if (*pcrl_score & CRL_SCORE_ISSUER_NAME) {", "            *pcrl_score |= CRL_SCORE_AKID | CRL_SCORE_ISSUER_CERT;", "            *pissuer = crl_issuer;", "            return;"], "SrcStart": 1217}, {"FileMD5": "275e2a08c0dedb2b56f9f36df0ea0b65.c", "FileName": "crypto/x509v3/v3_purp.c", "Line": 822, "Tip": "<b>issuer</b> is used as the 1st parameter in function <b>X509_get_issuer_name</b> (<b>issuer</b> can be null)", "SrcLines": ["            if (gen->type == GEN_DIRNAME) {", "                nm = gen->d.dirn;", "                break;", "            }", "        }", "        if (nm && X509_NAME_cmp(nm, X509_get_issuer_name(issuer)))", "            return X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH;", "    }", "    return X509_V_OK;", "}"], "SrcStart": 817}, {"FileMD5": "c3d35333c160e4c36abbd345287c2c1d.c", "FileName": "crypto/x509/x509_cmp.c", "Line": 85, "Tip": "Load value from <b>a-&gt;cert_info.issuer</b>", "SrcLines": ["    return memcmp(a->sha1_hash, b->sha1_hash, 20);", "}", "", "X509_NAME *X509_get_issuer_name(const X509 *a)", "{", "    return (a->cert_info.issuer);", "}", "", "unsigned long X509_issuer_name_hash(X509 *x)", "{"], "SrcStart": 80}], "Review": 80, "Time": 1630075188000, "DocID": "PE0001", "File": "crypto/x509/x509_cmp.c", "Line": 85}, {"HashID": "b4d882d03156cf47f4fef84dde3cef96", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "ca1bcbeb340dcd3309559e910e85ed73.c", "FileName": "crypto/stack/stack.c", "Line": 289, "Tip": "Return <b>null</b> to caller", "SrcLines": ["void *OPENSSL_sk_value(const OPENSSL_STACK *st, int i)", "{", "    if (st == NULL || i < 0 || i >= st->num)", "        return NULL;", "    return (void *)st->data[i];", "}", "", "void *OPENSSL_sk_set(OPENSSL_STACK *st, int i, const void *data)", "{", "    if (st == NULL || i < 0 || i >= st->num)"], "SrcStart": 284}, {"FileMD5": "bfba7e508f0613ec8f80e4651fe7d8ae.h", "FileName": "include/openssl/x509.h", "Line": 97, "Tip": "Return the return value of function <b>OPENSSL_sk_value</b> to caller", "SrcLines": ["", "typedef struct x509_cert_aux_st X509_CERT_AUX;", "", "typedef struct x509_cinf_st X509_CINF;", "", "DEFINE_STACK_OF(X509)", "", "/* This is used for a table of trust checking functions */", "", "typedef struct x509_trust_st {"], "SrcStart": 92}, {"FileMD5": "59a9b59273169ca11c8c5ce21773f8c5.c", "FileName": "crypto/x509/x509_vfy.c", "Line": 1314, "Tip": "Function <b>sk_X509_value</b> executes and stores the return value to <b>crl_ta</b> (<b>crl_ta</b> can be null)", "SrcLines": ["                           STACK_OF(X509) *cert_path,", "                           STACK_OF(X509) *crl_path)", "{", "    X509 *cert_ta, *crl_ta;", "    cert_ta = sk_X509_value(cert_path, sk_X509_num(cert_path) - 1);", "    crl_ta = sk_X509_value(crl_path, sk_X509_num(crl_path) - 1);", "    if (!X509_cmp(cert_ta, crl_ta))", "        return 1;", "    return 0;", "}"], "SrcStart": 1309}, {"FileMD5": "59a9b59273169ca11c8c5ce21773f8c5.c", "FileName": "crypto/x509/x509_vfy.c", "Line": 1315, "Tip": "<b>crl_ta</b> is used as the 2nd parameter in function <b>X509_cmp</b> (<b>crl_ta</b> can be null)", "SrcLines": ["                           STACK_OF(X509) *crl_path)", "{", "    X509 *cert_ta, *crl_ta;", "    cert_ta = sk_X509_value(cert_path, sk_X509_num(cert_path) - 1);", "    crl_ta = sk_X509_value(crl_path, sk_X509_num(crl_path) - 1);", "    if (!X509_cmp(cert_ta, crl_ta))", "        return 1;", "    return 0;", "}", ""], "SrcStart": 1310}, {"FileMD5": "c3d35333c160e4c36abbd345287c2c1d.c", "FileName": "crypto/x509/x509_cmp.c", "Line": 146, "Tip": "Load value from <b>b-&gt;cert_info.enc.modified</b>", "SrcLines": ["", "    rv = memcmp(a->sha1_hash, b->sha1_hash, SHA_DIGEST_LENGTH);", "    if (rv)", "        return rv;", "    /* Check for match against stored encoding too */", "    if (!a->cert_info.enc.modified && !b->cert_info.enc.modified) {", "        if (a->cert_info.enc.len < b->cert_info.enc.len)", "            return -1;", "        if (a->cert_info.enc.len > b->cert_info.enc.len)", "            return 1;"], "SrcStart": 141}], "Review": 80, "Time": 1630075188000, "DocID": "PE0001", "File": "crypto/x509/x509_cmp.c", "Line": 146}, {"HashID": "1bd1be5e857093ef4badeaad2b3a92d2", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "ca1bcbeb340dcd3309559e910e85ed73.c", "FileName": "crypto/stack/stack.c", "Line": 289, "Tip": "Return <b>null</b> to caller", "SrcLines": ["void *OPENSSL_sk_value(const OPENSSL_STACK *st, int i)", "{", "    if (st == NULL || i < 0 || i >= st->num)", "        return NULL;", "    return (void *)st->data[i];", "}", "", "void *OPENSSL_sk_set(OPENSSL_STACK *st, int i, const void *data)", "{", "    if (st == NULL || i < 0 || i >= st->num)"], "SrcStart": 284}, {"FileMD5": "788aedd001d2c53da267be53a07568c7.h", "FileName": "include/openssl/x509_vfy.h", "Line": 58, "Tip": "Return the return value of function <b>OPENSSL_sk_value</b> to caller", "SrcLines": ["#define X509_LU_RETRY   -1", "#define X509_LU_FAIL    0", "#endif", "", "DEFINE_STACK_OF(X509_LOOKUP)", "DEFINE_STACK_OF(X509_OBJECT)", "DEFINE_STACK_OF(X509_VERIFY_PARAM)", "", "int X509_STORE_set_depth(X509_STORE *store, int depth);", ""], "SrcStart": 53}, {"FileMD5": "a7547b090ef2a22b867037f771f5489f.c", "FileName": "crypto/x509/x509_lu.c", "Line": 594, "Tip": "Function <b>sk_X509_OBJECT_value</b> executes and stores the return value to <b>obj</b> (<b>obj</b> can be null)", "SrcLines": ["        sk_X509_CRL_free(sk);", "        return NULL;", "    }", "", "    for (i = 0; i < cnt; i++, idx++) {", "        obj = sk_X509_OBJECT_value(ctx->ctx->objs, idx);", "        x = obj->data.crl;", "        X509_CRL_up_ref(x);", "        if (!sk_X509_CRL_push(sk, x)) {", "            CRYPTO_THREAD_unlock(ctx->ctx->lock);"], "SrcStart": 589}, {"FileMD5": "a7547b090ef2a22b867037f771f5489f.c", "FileName": "crypto/x509/x509_lu.c", "Line": 595, "Tip": "Load value from <b>obj-&gt;value</b> and assign to <b>x</b>", "SrcLines": ["        return NULL;", "    }", "", "    for (i = 0; i < cnt; i++, idx++) {", "        obj = sk_X509_OBJECT_value(ctx->ctx->objs, idx);", "        x = obj->data.crl;", "        X509_CRL_up_ref(x);", "        if (!sk_X509_CRL_push(sk, x)) {", "            CRYPTO_THREAD_unlock(ctx->ctx->lock);", "            X509_CRL_free(x);"], "SrcStart": 590}], "Review": 80, "Time": 1630075188000, "DocID": "PE0001", "File": "crypto/x509/x509_lu.c", "Line": 595}, {"HashID": "4a46dedad3e86b232ab3db47dacd8fbf", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "ca1bcbeb340dcd3309559e910e85ed73.c", "FileName": "crypto/stack/stack.c", "Line": 289, "Tip": "Return <b>null</b> to caller", "SrcLines": ["void *OPENSSL_sk_value(const OPENSSL_STACK *st, int i)", "{", "    if (st == NULL || i < 0 || i >= st->num)", "        return NULL;", "    return (void *)st->data[i];", "}", "", "void *OPENSSL_sk_set(OPENSSL_STACK *st, int i, const void *data)", "{", "    if (st == NULL || i < 0 || i >= st->num)"], "SrcStart": 284}, {"FileMD5": "788aedd001d2c53da267be53a07568c7.h", "FileName": "include/openssl/x509_vfy.h", "Line": 58, "Tip": "Return the return value of function <b>OPENSSL_sk_value</b> to caller", "SrcLines": ["#define X509_LU_RETRY   -1", "#define X509_LU_FAIL    0", "#endif", "", "DEFINE_STACK_OF(X509_LOOKUP)", "DEFINE_STACK_OF(X509_OBJECT)", "DEFINE_STACK_OF(X509_VERIFY_PARAM)", "", "int X509_STORE_set_depth(X509_STORE *store, int depth);", ""], "SrcStart": 53}, {"FileMD5": "a7547b090ef2a22b867037f771f5489f.c", "FileName": "crypto/x509/x509_lu.c", "Line": 619, "Tip": "Store the return value of function <b>sk_X509_OBJECT_value</b> to <b>obj</b>", "SrcLines": ["    if (idx == -1)", "        return NULL;", "    if ((x->type != X509_LU_X509) && (x->type != X509_LU_CRL))", "        return sk_X509_OBJECT_value(h, idx);", "    for (i = idx; i < sk_X509_OBJECT_num(h); i++) {", "        obj = sk_X509_OBJECT_value(h, i);", "        if (x509_object_cmp", "            ((const X509_OBJECT **)&obj, (const X509_OBJECT **)&x))", "            return NULL;", "        if (x->type == X509_LU_X509) {"], "SrcStart": 614}, {"FileMD5": "a7547b090ef2a22b867037f771f5489f.c", "FileName": "crypto/x509/x509_lu.c", "Line": 624, "Tip": "Load value from <b>obj</b>", "SrcLines": ["        obj = sk_X509_OBJECT_value(h, i);", "        if (x509_object_cmp", "            ((const X509_OBJECT **)&obj, (const X509_OBJECT **)&x))", "            return NULL;", "        if (x->type == X509_LU_X509) {", "            if (!X509_cmp(obj->data.x509, x->data.x509))", "                return obj;", "        } else if (x->type == X509_LU_CRL) {", "            if (!X509_CRL_match(obj->data.crl, x->data.crl))", "                return obj;"], "SrcStart": 619}, {"FileMD5": "a7547b090ef2a22b867037f771f5489f.c", "FileName": "crypto/x509/x509_lu.c", "Line": 624, "Tip": "Load value from <b>obj-&gt;value</b>", "SrcLines": ["        obj = sk_X509_OBJECT_value(h, i);", "        if (x509_object_cmp", "            ((const X509_OBJECT **)&obj, (const X509_OBJECT **)&x))", "            return NULL;", "        if (x->type == X509_LU_X509) {", "            if (!X509_cmp(obj->data.x509, x->data.x509))", "                return obj;", "        } else if (x->type == X509_LU_CRL) {", "            if (!X509_CRL_match(obj->data.crl, x->data.crl))", "                return obj;"], "SrcStart": 619}], "Review": 80, "Time": 1630075188000, "DocID": "PE0001", "File": "crypto/x509/x509_lu.c", "Line": 624}, {"HashID": "72e25a575b4572f9b7d157d90f5074de", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "ca1bcbeb340dcd3309559e910e85ed73.c", "FileName": "crypto/stack/stack.c", "Line": 289, "Tip": "Return <b>null</b> to caller", "SrcLines": ["void *OPENSSL_sk_value(const OPENSSL_STACK *st, int i)", "{", "    if (st == NULL || i < 0 || i >= st->num)", "        return NULL;", "    return (void *)st->data[i];", "}", "", "void *OPENSSL_sk_set(OPENSSL_STACK *st, int i, const void *data)", "{", "    if (st == NULL || i < 0 || i >= st->num)"], "SrcStart": 284}, {"FileMD5": "bfba7e508f0613ec8f80e4651fe7d8ae.h", "FileName": "include/openssl/x509.h", "Line": 97, "Tip": "Return the return value of function <b>OPENSSL_sk_value</b> to caller", "SrcLines": ["", "typedef struct x509_cert_aux_st X509_CERT_AUX;", "", "typedef struct x509_cinf_st X509_CINF;", "", "DEFINE_STACK_OF(X509)", "", "/* This is used for a table of trust checking functions */", "", "typedef struct x509_trust_st {"], "SrcStart": 92}, {"FileMD5": "c3d35333c160e4c36abbd345287c2c1d.c", "FileName": "crypto/x509/x509_cmp.c", "Line": 359, "Tip": "Function <b>sk_X509_value</b> executes and stores the return value to <b>x</b> (<b>x</b> can be null)", "SrcLines": ["    if (!(flags & X509_V_FLAG_SUITEB_128_LOS))", "        return X509_V_OK;", "", "    /* If no EE certificate passed in must be first in chain */", "    if (x == NULL) {", "        x = sk_X509_value(chain, 0);", "        i = 1;", "    } else", "        i = 0;", ""], "SrcStart": 354}, {"FileMD5": "c3d35333c160e4c36abbd345287c2c1d.c", "FileName": "crypto/x509/x509_cmp.c", "Line": 375, "Tip": "<b>x</b> is used as the 1st parameter in function <b>X509_get_version</b> (<b>x</b> can be null)", "SrcLines": ["     * pointer.  All we need to do is check the leaf key algorithm.", "     */", "    if (chain == NULL)", "        return check_suite_b(pk, -1, &tflags);", "", "    if (X509_get_version(x) != 2) {", "        rv = X509_V_ERR_SUITE_B_INVALID_VERSION;", "        /* Correct error depth */", "        i = 0;", "        goto end;"], "SrcStart": 370}, {"FileMD5": "6f4e3a36d2997dcc779bf4ffafd3c117.c", "FileName": "crypto/x509/x509_set.c", "Line": 109, "Tip": "Load value from <b>x-&gt;cert_info.version</b>", "SrcLines": ["    return ((i > 1) ? 1 : 0);", "}", "", "long X509_get_version(const X509 *x)", "{", "    return ASN1_INTEGER_get(x->cert_info.version);", "}", "", "const ASN1_TIME *X509_get0_notBefore(const X509 *x)", "{"], "SrcStart": 104}], "Review": 80, "Time": 1630075188000, "DocID": "PE0001", "File": "crypto/x509/x509_set.c", "Line": 109}, {"HashID": "dccb3210280d951f84e1ff951ffb9e89", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "ca1bcbeb340dcd3309559e910e85ed73.c", "FileName": "crypto/stack/stack.c", "Line": 289, "Tip": "Return <b>null</b> to caller", "SrcLines": ["void *OPENSSL_sk_value(const OPENSSL_STACK *st, int i)", "{", "    if (st == NULL || i < 0 || i >= st->num)", "        return NULL;", "    return (void *)st->data[i];", "}", "", "void *OPENSSL_sk_set(OPENSSL_STACK *st, int i, const void *data)", "{", "    if (st == NULL || i < 0 || i >= st->num)"], "SrcStart": 284}, {"FileMD5": "bfba7e508f0613ec8f80e4651fe7d8ae.h", "FileName": "include/openssl/x509.h", "Line": 97, "Tip": "Return the return value of function <b>OPENSSL_sk_value</b> to caller", "SrcLines": ["", "typedef struct x509_cert_aux_st X509_CERT_AUX;", "", "typedef struct x509_cinf_st X509_CINF;", "", "DEFINE_STACK_OF(X509)", "", "/* This is used for a table of trust checking functions */", "", "typedef struct x509_trust_st {"], "SrcStart": 92}, {"FileMD5": "59a9b59273169ca11c8c5ce21773f8c5.c", "FileName": "crypto/x509/x509_vfy.c", "Line": 1701, "Tip": "Function <b>sk_X509_value</b> executes and stores the return value to <b>xs</b> (<b>xs</b> can be null)", "SrcLines": ["}", "", "static int internal_verify(X509_STORE_CTX *ctx)", "{", "    int n = sk_X509_num(ctx->chain) - 1;", "    X509 *xi = sk_X509_value(ctx->chain, n);", "    X509 *xs;", "", "    /*", "     * With DANE-verified bare public key TA signatures, it remains only to"], "SrcStart": 1696}, {"FileMD5": "59a9b59273169ca11c8c5ce21773f8c5.c", "FileName": "crypto/x509/x509_vfy.c", "Line": 1757, "Tip": "<b>xs</b> is used as the 2nd parameter in function <b>x509_check_cert_time</b> (<b>xs</b> can be null)", "SrcLines": ["            }", "        }", "", " check_cert:", "        /* Calls verify callback as needed */", "        if (!x509_check_cert_time(ctx, xs, n))", "            return 0;", "", "        /*", "         * Signal success at this depth.  However, the previous error (if any)"], "SrcStart": 1752}, {"FileMD5": "59a9b59273169ca11c8c5ce21773f8c5.c", "FileName": "crypto/x509/x509_vfy.c", "Line": 1678, "Tip": "<b>x</b> is used as the 1st parameter in function <b>X509_get0_notBefore</b> (<b>x</b> can be null)", "SrcLines": ["    else if (ctx->param->flags & X509_V_FLAG_NO_CHECK_TIME)", "        return 1;", "    else", "        ptime = NULL;", "", "    i = X509_cmp_time(X509_get0_notBefore(x), ptime);", "    if (i >= 0 && depth < 0)", "        return 0;", "    if (i == 0 && !verify_cb_cert(ctx, x, depth,", "                                  X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD))"], "SrcStart": 1673}, {"FileMD5": "6f4e3a36d2997dcc779bf4ffafd3c117.c", "FileName": "crypto/x509/x509_set.c", "Line": 114, "Tip": "Load value from <b>x-&gt;cert_info.validity.salt</b>", "SrcLines": ["    return ASN1_INTEGER_get(x->cert_info.version);", "}", "", "const ASN1_TIME *X509_get0_notBefore(const X509 *x)", "{", "    return x->cert_info.validity.notBefore;", "}", "", "const ASN1_TIME *X509_get0_notAfter(const X509 *x)", "{"], "SrcStart": 109}], "Review": 80, "Time": 1630075188000, "DocID": "PE0001", "File": "crypto/x509/x509_set.c", "Line": 114}, {"HashID": "786078a13fe065f2787d6a4a2884901d", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "ca1bcbeb340dcd3309559e910e85ed73.c", "FileName": "crypto/stack/stack.c", "Line": 289, "Tip": "Return <b>null</b> to caller", "SrcLines": ["void *OPENSSL_sk_value(const OPENSSL_STACK *st, int i)", "{", "    if (st == NULL || i < 0 || i >= st->num)", "        return NULL;", "    return (void *)st->data[i];", "}", "", "void *OPENSSL_sk_set(OPENSSL_STACK *st, int i, const void *data)", "{", "    if (st == NULL || i < 0 || i >= st->num)"], "SrcStart": 284}, {"FileMD5": "bfba7e508f0613ec8f80e4651fe7d8ae.h", "FileName": "include/openssl/x509.h", "Line": 110, "Tip": "Return the return value of function <b>OPENSSL_sk_value</b> to caller", "SrcLines": ["    char *name;", "    int arg1;", "    void *arg2;", "} X509_TRUST;", "", "DEFINE_STACK_OF(X509_TRUST)", "", "/* standard trust ids */", "", "# define X509_TRUST_DEFAULT      0 /* Only valid in purpose settings */"], "SrcStart": 105}, {"FileMD5": "9a2453df94fd9cedfc1d79d3b0158ffc.c", "FileName": "crypto/x509/x509_trs.c", "Line": 94, "Tip": "Function <b>sk_X509_TRUST_value</b> executes and returns", "SrcLines": ["{", "    if (idx < 0)", "        return NULL;", "    if (idx < (int)X509_TRUST_COUNT)", "        return trstandard + idx;", "    return sk_X509_TRUST_value(trtable, idx - X509_TRUST_COUNT);", "}", "", "int X509_TRUST_get_by_id(int id)", "{"], "SrcStart": 89}, {"FileMD5": "9a2453df94fd9cedfc1d79d3b0158ffc.c", "FileName": "crypto/x509/x509_trs.c", "Line": 95, "Tip": "Return the return value of function <b>sk_X509_TRUST_value</b> to caller (The return value can be null)", "SrcLines": ["    if (idx < 0)", "        return NULL;", "    if (idx < (int)X509_TRUST_COUNT)", "        return trstandard + idx;", "    return sk_X509_TRUST_value(trtable, idx - X509_TRUST_COUNT);", "}", "", "int X509_TRUST_get_by_id(int id)", "{", "    X509_TRUST tmp;"], "SrcStart": 90}, {"FileMD5": "9a2453df94fd9cedfc1d79d3b0158ffc.c", "FileName": "crypto/x509/x509_trs.c", "Line": 77, "Tip": "Function <b>X509_TRUST_get0</b> executes and stores the return value to <b>pt</b> (<b>pt</b> can be null)", "SrcLines": ["        return obj_trust(NID_anyExtendedKeyUsage, x,", "                         flags | X509_TRUST_DO_SS_COMPAT);", "    idx = X509_TRUST_get_by_id(id);", "    if (idx == -1)", "        return default_trust(id, x, flags);", "    pt = X509_TRUST_get0(idx);", "    return pt->check_trust(pt, x, flags);", "}", "", "int X509_TRUST_get_count(void)"], "SrcStart": 72}, {"FileMD5": "9a2453df94fd9cedfc1d79d3b0158ffc.c", "FileName": "crypto/x509/x509_trs.c", "Line": 78, "Tip": "Load value from <b>pt-&gt;check_trust</b>", "SrcLines": ["                         flags | X509_TRUST_DO_SS_COMPAT);", "    idx = X509_TRUST_get_by_id(id);", "    if (idx == -1)", "        return default_trust(id, x, flags);", "    pt = X509_TRUST_get0(idx);", "    return pt->check_trust(pt, x, flags);", "}", "", "int X509_TRUST_get_count(void)", "{"], "SrcStart": 73}], "Review": 80, "Time": 1630075188000, "DocID": "PE0001", "File": "crypto/x509/x509_trs.c", "Line": 78}, {"HashID": "a614261071cf3719df7fd81ae85f3d1d", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "9a2453df94fd9cedfc1d79d3b0158ffc.c", "FileName": "crypto/x509/x509_trs.c", "Line": 95, "Tip": "Return <b>null</b> to caller", "SrcLines": ["    if (idx < 0)", "        return NULL;", "    if (idx < (int)X509_TRUST_COUNT)", "        return trstandard + idx;", "    return sk_X509_TRUST_value(trtable, idx - X509_TRUST_COUNT);", "}", "", "int X509_TRUST_get_by_id(int id)", "{", "    X509_TRUST tmp;"], "SrcStart": 90}, {"FileMD5": "9a2453df94fd9cedfc1d79d3b0158ffc.c", "FileName": "crypto/x509/x509_trs.c", "Line": 143, "Tip": "Function <b>X509_TRUST_get0</b> executes and stores the return value to <b>trtmp</b> (<b>trtmp</b> can be null)", "SrcLines": ["            X509err(X509_F_X509_TRUST_ADD, ERR_R_MALLOC_FAILURE);", "            return 0;", "        }", "        trtmp->flags = X509_TRUST_DYNAMIC;", "    } else", "        trtmp = X509_TRUST_get0(idx);", "", "    /* OPENSSL_free existing name if dynamic */", "    if (trtmp->flags & X509_TRUST_DYNAMIC_NAME)", "        OPENSSL_free(trtmp->name);"], "SrcStart": 138}, {"FileMD5": "9a2453df94fd9cedfc1d79d3b0158ffc.c", "FileName": "crypto/x509/x509_trs.c", "Line": 146, "Tip": "Load value from <b>trtmp-&gt;flags</b>", "SrcLines": ["        trtmp->flags = X509_TRUST_DYNAMIC;", "    } else", "        trtmp = X509_TRUST_get0(idx);", "", "    /* OPENSSL_free existing name if dynamic */", "    if (trtmp->flags & X509_TRUST_DYNAMIC_NAME)", "        OPENSSL_free(trtmp->name);", "    /* dup supplied name */", "    if ((trtmp->name = OPENSSL_strdup(name)) == NULL) {", "        X509err(X509_F_X509_TRUST_ADD, ERR_R_MALLOC_FAILURE);"], "SrcStart": 141}], "Review": 80, "Time": 1630075188000, "DocID": "PE0001", "File": "crypto/x509/x509_trs.c", "Line": 146}]}, "start": 51, "end": 60, "page": 7, "total_pages": 11, "language": "en"}