var data = {"bug_cases": {"BugType": "NULL pointer dereference", "Severity": 12, "CaseList": [{"HashID": "a6fa99bfe291d6cbb7be87e8178aa2e4", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "6c33ffba0fd02c740e37dafb241c5c96.c", "FileName": "crypto/x509/x509name.c", "Line": 94, "Tip": "Return <b>null</b> to caller", "SrcLines": ["    if (name == NULL || sk_X509_NAME_ENTRY_num(name->entries) <= loc", "        || loc < 0)", "        return NULL;", "", "    return sk_X509_NAME_ENTRY_value(name->entries, loc);", "}", "", "X509_NAME_ENTRY *X509_NAME_delete_entry(X509_NAME *name, int loc)", "{", "    X509_NAME_ENTRY *ret;"], "SrcStart": 89}, {"FileMD5": "87527097900edf976ffa31138e4c5ff9.c", "FileName": "crypto/x509/x509_vfy.c", "Line": 662, "Tip": "The return value of function <b>X509_NAME_get_entry</b> is used as the 1st parameter in function <b>X509_NAME_ENTRY_set</b> (the return value of function <b>X509_NAME_get_entry</b> can be null)", "SrcLines": ["             * Check that the last subject component isn't part of a", "             * multivalued RDN", "             */", "            if (X509_NAME_ENTRY_set(X509_NAME_get_entry(tmpsubject,", "                                                        last_object_loc))", "                == X509_NAME_ENTRY_set(X509_NAME_get_entry(tmpsubject,", "                                                           last_object_loc - 1))) {", "                err = X509_V_ERR_PROXY_SUBJECT_NAME_VIOLATION;", "                goto proxy_name_done;", "            }"], "SrcStart": 657}, {"FileMD5": "6c33ffba0fd02c740e37dafb241c5c96.c", "FileName": "crypto/x509/x509name.c", "Line": 359, "Tip": "Load value from <b>ne-&gt;set</b>", "SrcLines": ["    return ne->value;", "}", "", "int X509_NAME_ENTRY_set(const X509_NAME_ENTRY *ne)", "{", "    return ne->set;", "}"], "SrcStart": 354}], "Review": 80, "Time": 1630075710000, "DocID": "PE0001", "File": "crypto/x509/x509name.c", "Line": 359}, {"HashID": "16d1dba3feb4d1e90451e1eff57bbad1", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "75ebffad16e89306fda76d6551ed7b03.c", "FileName": "crypto/x509/x_pubkey.c", "Line": 167, "Tip": "Return <b>null</b> to caller", "SrcLines": ["        X509err(X509_F_X509_PUBKEY_GET0, ERR_R_INTERNAL_ERROR);", "        EVP_PKEY_free(ret);", "    }", "", "    return NULL;", "}", "", "EVP_PKEY *X509_PUBKEY_get(X509_PUBKEY *key)", "{", "    EVP_PKEY *ret = X509_PUBKEY_get0(key);"], "SrcStart": 162}, {"FileMD5": "7c9e4de7e709d5101ccb55eeaa778475.c", "FileName": "crypto/x509/x509_cmp.c", "Line": 277, "Tip": "Function <b>X509_PUBKEY_get0</b> executes and returns", "SrcLines": ["", "EVP_PKEY *X509_get0_pubkey(const X509 *x)", "{", "    if (x == NULL)", "        return NULL;", "    return X509_PUBKEY_get0(x->cert_info.key);", "}", "", "EVP_PKEY *X509_get_pubkey(X509 *x)", "{"], "SrcStart": 272}, {"FileMD5": "7c9e4de7e709d5101ccb55eeaa778475.c", "FileName": "crypto/x509/x509_cmp.c", "Line": 278, "Tip": "Return the return value of function <b>X509_PUBKEY_get0</b> to caller (The return value can be null)", "SrcLines": ["EVP_PKEY *X509_get0_pubkey(const X509 *x)", "{", "    if (x == NULL)", "        return NULL;", "    return X509_PUBKEY_get0(x->cert_info.key);", "}", "", "EVP_PKEY *X509_get_pubkey(X509 *x)", "{", "    if (x == NULL)"], "SrcStart": 273}, {"FileMD5": "5cd87c274e2109ba17cf2f05e89ce22f.c", "FileName": "crypto/ct/ct_sct.c", "Line": 332, "Tip": "Function <b>X509_get0_pubkey</b> executes and stores the return value to <b>issuer_pkey</b> (<b>issuer_pkey</b> can be null)", "SrcLines": ["        if (ctx->issuer == NULL) {", "            sct->validation_status = SCT_VALIDATION_STATUS_UNVERIFIED;", "            goto end;", "        }", "", "        issuer_pkey = X509_get0_pubkey(ctx->issuer);", "", "        if (X509_PUBKEY_set(&pub, issuer_pkey) != 1)", "            goto err;", "        if (SCT_CTX_set1_issuer_pubkey(sctx, pub) != 1)"], "SrcStart": 327}, {"FileMD5": "5cd87c274e2109ba17cf2f05e89ce22f.c", "FileName": "crypto/ct/ct_sct.c", "Line": 334, "Tip": "<b>issuer_pkey</b> is used as the 2nd parameter in function <b>X509_PUBKEY_set</b> (<b>issuer_pkey</b> can be null)", "SrcLines": ["            goto end;", "        }", "", "        issuer_pkey = X509_get0_pubkey(ctx->issuer);", "", "        if (X509_PUBKEY_set(&pub, issuer_pkey) != 1)", "            goto err;", "        if (SCT_CTX_set1_issuer_pubkey(sctx, pub) != 1)", "            goto err;", "    }"], "SrcStart": 329}, {"FileMD5": "75ebffad16e89306fda76d6551ed7b03.c", "FileName": "crypto/x509/x_pubkey.c", "Line": 70, "Tip": "Load value from <b>pkey-&gt;ameth</b>", "SrcLines": ["        return 0;", "", "    if ((pk = X509_PUBKEY_new()) == NULL)", "        goto error;", "", "    if (pkey->ameth) {", "        if (pkey->ameth->pub_encode) {", "            if (!pkey->ameth->pub_encode(pk, pkey)) {", "                X509err(X509_F_X509_PUBKEY_SET,", "                        X509_R_PUBLIC_KEY_ENCODE_ERROR);"], "SrcStart": 65}], "Review": 80, "Time": 1630075710000, "DocID": "PE0001", "File": "crypto/x509/x_pubkey.c", "Line": 70}, {"HashID": "bd3060b30e5fb58290e711b97537b804", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "f2272d8c3c73e81d46873146c8a9a7e1.c", "FileName": "crypto/stack/stack.c", "Line": 390, "Tip": "Return <b>null</b> to caller", "SrcLines": ["void *OPENSSL_sk_value(const OPENSSL_STACK *st, int i)", "{", "    if (st == NULL || i < 0 || i >= st->num)", "        return NULL;", "    return (void *)st->data[i];", "}", "", "void *OPENSSL_sk_set(OPENSSL_STACK *st, int i, const void *data)", "{", "    if (st == NULL || i < 0 || i >= st->num)"], "SrcStart": 385}, {"FileMD5": "bca7eb7c72dbbf6d7fcda63514d9f27e.h", "FileName": "include/openssl/x509.h", "Line": 99, "Tip": "Return the return value of function <b>OPENSSL_sk_value</b> to caller", "SrcLines": ["", "typedef struct x509_cert_aux_st X509_CERT_AUX;", "", "typedef struct x509_cinf_st X509_CINF;", "", "DEFINE_STACK_OF(X509)", "", "/* This is used for a table of trust checking functions */", "", "typedef struct x509_trust_st {"], "SrcStart": 94}, {"FileMD5": "24eea33f4a2a3312aa9d9b64c16dbf72.c", "FileName": "crypto/x509v3/pcy_tree.c", "Line": 115, "Tip": "Function <b>sk_X509_value</b> executes and stores the return value to <b>x</b> (<b>x</b> can be null)", "SrcLines": ["     * First setup the policy cache in all n non-TA certificates, this will be", "     * used in X509_verify_cert() which will invoke the verify callback for all", "     * certificates with invalid policy extensions.", "     */", "    for (i = n - 1; i >= 0; i--) {", "        X509 *x = sk_X509_value(certs, i);", "", "        /* Call for side-effect of computing hash and caching extensions */", "        X509_check_purpose(x, -1, 0);", ""], "SrcStart": 110}, {"FileMD5": "24eea33f4a2a3312aa9d9b64c16dbf72.c", "FileName": "crypto/x509v3/pcy_tree.c", "Line": 121, "Tip": "<b>x</b> is used as the 1st parameter in function <b>policy_cache_set</b> (<b>x</b> can be null)", "SrcLines": ["", "        /* Call for side-effect of computing hash and caching extensions */", "        X509_check_purpose(x, -1, 0);", "", "        /* If cache is NULL, likely ENOMEM: return immediately */", "        if (policy_cache_set(x) == NULL)", "            return X509_PCY_TREE_INTERNAL;", "    }", "", "    /*"], "SrcStart": 116}, {"FileMD5": "214ef24c7eae11cc6462d7754f7b6066.c", "FileName": "crypto/x509v3/pcy_cache.c", "Line": 190, "Tip": "Load value from <b>x-&gt;policy_cache</b>", "SrcLines": ["}", "", "const X509_POLICY_CACHE *policy_cache_set(X509 *x)", "{", "", "    if (x->policy_cache == NULL) {", "        CRYPTO_THREAD_write_lock(x->lock);", "        policy_cache_new(x);", "        CRYPTO_THREAD_unlock(x->lock);", "    }"], "SrcStart": 185}], "Review": 80, "Time": 1630075710000, "DocID": "PE0001", "File": "crypto/x509v3/pcy_cache.c", "Line": 190}, {"HashID": "6ff710b0e6badcc7257bbba9f9759ae1", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "f2272d8c3c73e81d46873146c8a9a7e1.c", "FileName": "crypto/stack/stack.c", "Line": 390, "Tip": "Return <b>null</b> to caller", "SrcLines": ["void *OPENSSL_sk_value(const OPENSSL_STACK *st, int i)", "{", "    if (st == NULL || i < 0 || i >= st->num)", "        return NULL;", "    return (void *)st->data[i];", "}", "", "void *OPENSSL_sk_set(OPENSSL_STACK *st, int i, const void *data)", "{", "    if (st == NULL || i < 0 || i >= st->num)"], "SrcStart": 385}, {"FileMD5": "9ddc19d042d192d7e7a40939177ad903.h", "FileName": "include/openssl/x509v3.h", "Line": 722, "Tip": "Return the return value of function <b>OPENSSL_sk_value</b> to caller", "SrcLines": ["ASN1_OCTET_STRING *a2i_IPADDRESS_NC(const char *ipasc);", "int X509V3_NAME_from_section(X509_NAME *nm, STACK_OF(CONF_VALUE) *dn_sk,", "                             unsigned long chtype);", "", "void X509_POLICY_NODE_print(BIO *out, X509_POLICY_NODE *node, int indent);", "DEFINE_STACK_OF(X509_POLICY_NODE)", "", "#ifndef OPENSSL_NO_RFC3779", "typedef struct ASRange_st {", "    ASN1_INTEGER *min, *max;"], "SrcStart": 717}, {"FileMD5": "24eea33f4a2a3312aa9d9b64c16dbf72.c", "FileName": "crypto/x509v3/pcy_tree.c", "Line": 399, "Tip": "Function <b>sk_X509_POLICY_NODE_value</b> executes and stores the return value to <b>node</b> (<b>node</b> can be null)", "SrcLines": ["    X509_POLICY_NODE *node;", "    int i;", "    nodes = curr->nodes;", "    if (curr->flags & X509_V_FLAG_INHIBIT_MAP) {", "        for (i = sk_X509_POLICY_NODE_num(nodes) - 1; i >= 0; i--) {", "            node = sk_X509_POLICY_NODE_value(nodes, i);", "            /* Delete any mapped data: see RFC3280 XXXX */", "            if (node->data->flags & POLICY_DATA_FLAG_MAP_MASK) {", "                node->parent->nchild--;", "                OPENSSL_free(node);"], "SrcStart": 394}, {"FileMD5": "24eea33f4a2a3312aa9d9b64c16dbf72.c", "FileName": "crypto/x509v3/pcy_tree.c", "Line": 401, "Tip": "Load value from <b>node-&gt;data</b>", "SrcLines": ["    nodes = curr->nodes;", "    if (curr->flags & X509_V_FLAG_INHIBIT_MAP) {", "        for (i = sk_X509_POLICY_NODE_num(nodes) - 1; i >= 0; i--) {", "            node = sk_X509_POLICY_NODE_value(nodes, i);", "            /* Delete any mapped data: see RFC3280 XXXX */", "            if (node->data->flags & POLICY_DATA_FLAG_MAP_MASK) {", "                node->parent->nchild--;", "                OPENSSL_free(node);", "                (void)sk_X509_POLICY_NODE_delete(nodes, i);", "            }"], "SrcStart": 396}], "Review": 80, "Time": 1630075710000, "DocID": "PE0001", "File": "crypto/x509v3/pcy_tree.c", "Line": 401}, {"HashID": "d523e13d2db88163ef35fee4c7a7a8cc", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "f2272d8c3c73e81d46873146c8a9a7e1.c", "FileName": "crypto/stack/stack.c", "Line": 390, "Tip": "Return <b>null</b> to caller", "SrcLines": ["void *OPENSSL_sk_value(const OPENSSL_STACK *st, int i)", "{", "    if (st == NULL || i < 0 || i >= st->num)", "        return NULL;", "    return (void *)st->data[i];", "}", "", "void *OPENSSL_sk_set(OPENSSL_STACK *st, int i, const void *data)", "{", "    if (st == NULL || i < 0 || i >= st->num)"], "SrcStart": 385}, {"FileMD5": "9ddc19d042d192d7e7a40939177ad903.h", "FileName": "include/openssl/x509v3.h", "Line": 722, "Tip": "Return the return value of function <b>OPENSSL_sk_value</b> to caller", "SrcLines": ["ASN1_OCTET_STRING *a2i_IPADDRESS_NC(const char *ipasc);", "int X509V3_NAME_from_section(X509_NAME *nm, STACK_OF(CONF_VALUE) *dn_sk,", "                             unsigned long chtype);", "", "void X509_POLICY_NODE_print(BIO *out, X509_POLICY_NODE *node, int indent);", "DEFINE_STACK_OF(X509_POLICY_NODE)", "", "#ifndef OPENSSL_NO_RFC3779", "typedef struct ASRange_st {", "    ASN1_INTEGER *min, *max;"], "SrcStart": 717}, {"FileMD5": "24eea33f4a2a3312aa9d9b64c16dbf72.c", "FileName": "crypto/x509v3/pcy_tree.c", "Line": 413, "Tip": "Function <b>sk_X509_POLICY_NODE_value</b> executes and stores the return value to <b>node</b> (<b>node</b> can be null)", "SrcLines": ["", "    for (;;) {", "        --curr;", "        nodes = curr->nodes;", "        for (i = sk_X509_POLICY_NODE_num(nodes) - 1; i >= 0; i--) {", "            node = sk_X509_POLICY_NODE_value(nodes, i);", "            if (node->nchild == 0) {", "                node->parent->nchild--;", "                OPENSSL_free(node);", "                (void)sk_X509_POLICY_NODE_delete(nodes, i);"], "SrcStart": 408}, {"FileMD5": "24eea33f4a2a3312aa9d9b64c16dbf72.c", "FileName": "crypto/x509v3/pcy_tree.c", "Line": 414, "Tip": "Load value from <b>node-&gt;nchild</b>", "SrcLines": ["    for (;;) {", "        --curr;", "        nodes = curr->nodes;", "        for (i = sk_X509_POLICY_NODE_num(nodes) - 1; i >= 0; i--) {", "            node = sk_X509_POLICY_NODE_value(nodes, i);", "            if (node->nchild == 0) {", "                node->parent->nchild--;", "                OPENSSL_free(node);", "                (void)sk_X509_POLICY_NODE_delete(nodes, i);", "            }"], "SrcStart": 409}], "Review": 80, "Time": 1630075710000, "DocID": "PE0001", "File": "crypto/x509v3/pcy_tree.c", "Line": 414}, {"HashID": "a08b363d50cc9ce7db928ae567092aa8", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "f2272d8c3c73e81d46873146c8a9a7e1.c", "FileName": "crypto/stack/stack.c", "Line": 390, "Tip": "Return <b>null</b> to caller", "SrcLines": ["void *OPENSSL_sk_value(const OPENSSL_STACK *st, int i)", "{", "    if (st == NULL || i < 0 || i >= st->num)", "        return NULL;", "    return (void *)st->data[i];", "}", "", "void *OPENSSL_sk_set(OPENSSL_STACK *st, int i, const void *data)", "{", "    if (st == NULL || i < 0 || i >= st->num)"], "SrcStart": 385}, {"FileMD5": "9ddc19d042d192d7e7a40939177ad903.h", "FileName": "include/openssl/x509v3.h", "Line": 798, "Tip": "Return the return value of function <b>OPENSSL_sk_value</b> to caller", "SrcLines": ["    ASN1_OCTET_STRING *addressFamily;", "    IPAddressChoice *ipAddressChoice;", "} IPAddressFamily;", "", "typedef STACK_OF(IPAddressFamily) IPAddrBlocks;", "DEFINE_STACK_OF(IPAddressFamily)", "", "DECLARE_ASN1_FUNCTIONS(IPAddressRange)", "DECLARE_ASN1_FUNCTIONS(IPAddressOrRange)", "DECLARE_ASN1_FUNCTIONS(IPAddressChoice)"], "SrcStart": 793}, {"FileMD5": "b7aa77bcebfce1216c4d6dcbebdbb3a6.c", "FileName": "crypto/x509v3/v3_addr.c", "Line": 1229, "Tip": "Function <b>sk_IPAddressFamily_value</b> executes and stores the return value to <b>fc</b> (<b>fc</b> can be null)", "SrcLines": ["        x = sk_X509_value(chain, i);", "        if (!X509v3_addr_is_canonical(x->rfc3779_addr))", "            validation_err(X509_V_ERR_INVALID_EXTENSION);", "        if (x->rfc3779_addr == NULL) {", "            for (j = 0; j < sk_IPAddressFamily_num(child); j++) {", "                IPAddressFamily *fc = sk_IPAddressFamily_value(child, j);", "                if (fc->ipAddressChoice->type != IPAddressChoice_inherit) {", "                    validation_err(X509_V_ERR_UNNESTED_RESOURCE);", "                    break;", "                }"], "SrcStart": 1224}, {"FileMD5": "b7aa77bcebfce1216c4d6dcbebdbb3a6.c", "FileName": "crypto/x509v3/v3_addr.c", "Line": 1230, "Tip": "Load value from <b>fc-&gt;ipAddressChoice</b>", "SrcLines": ["        if (!X509v3_addr_is_canonical(x->rfc3779_addr))", "            validation_err(X509_V_ERR_INVALID_EXTENSION);", "        if (x->rfc3779_addr == NULL) {", "            for (j = 0; j < sk_IPAddressFamily_num(child); j++) {", "                IPAddressFamily *fc = sk_IPAddressFamily_value(child, j);", "                if (fc->ipAddressChoice->type != IPAddressChoice_inherit) {", "                    validation_err(X509_V_ERR_UNNESTED_RESOURCE);", "                    break;", "                }", "            }"], "SrcStart": 1225}], "Review": 80, "Time": 1630075710000, "DocID": "PE0001", "File": "crypto/x509v3/v3_addr.c", "Line": 1230}, {"HashID": "62bb8389e64d040d9cfead9595bb84fa", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "f2272d8c3c73e81d46873146c8a9a7e1.c", "FileName": "crypto/stack/stack.c", "Line": 390, "Tip": "Return <b>null</b> to caller", "SrcLines": ["void *OPENSSL_sk_value(const OPENSSL_STACK *st, int i)", "{", "    if (st == NULL || i < 0 || i >= st->num)", "        return NULL;", "    return (void *)st->data[i];", "}", "", "void *OPENSSL_sk_set(OPENSSL_STACK *st, int i, const void *data)", "{", "    if (st == NULL || i < 0 || i >= st->num)"], "SrcStart": 385}, {"FileMD5": "bca7eb7c72dbbf6d7fcda63514d9f27e.h", "FileName": "include/openssl/x509.h", "Line": 99, "Tip": "Return the return value of function <b>OPENSSL_sk_value</b> to caller", "SrcLines": ["", "typedef struct x509_cert_aux_st X509_CERT_AUX;", "", "typedef struct x509_cinf_st X509_CINF;", "", "DEFINE_STACK_OF(X509)", "", "/* This is used for a table of trust checking functions */", "", "typedef struct x509_trust_st {"], "SrcStart": 94}, {"FileMD5": "87527097900edf976ffa31138e4c5ff9.c", "FileName": "crypto/x509/x509_vfy.c", "Line": 2931, "Tip": "Function <b>sk_X509_value</b> executes and stores the return value to <b>cert</b> (<b>cert</b> can be null)", "SrcLines": ["", "static int build_chain(X509_STORE_CTX *ctx)", "{", "    SSL_DANE *dane = ctx->dane;", "    int num = sk_X509_num(ctx->chain);", "    X509 *cert = sk_X509_value(ctx->chain, num - 1);", "    int ss = cert_self_signed(cert);", "    STACK_OF(X509) *sktmp = NULL;", "    unsigned int search;", "    int may_trusted = 0;"], "SrcStart": 2926}, {"FileMD5": "87527097900edf976ffa31138e4c5ff9.c", "FileName": "crypto/x509/x509_vfy.c", "Line": 2932, "Tip": "<b>cert</b> is used as the 1st parameter in function <b>cert_self_signed</b> (<b>cert</b> can be null)", "SrcLines": ["static int build_chain(X509_STORE_CTX *ctx)", "{", "    SSL_DANE *dane = ctx->dane;", "    int num = sk_X509_num(ctx->chain);", "    X509 *cert = sk_X509_value(ctx->chain, num - 1);", "    int ss = cert_self_signed(cert);", "    STACK_OF(X509) *sktmp = NULL;", "    unsigned int search;", "    int may_trusted = 0;", "    int may_alternate = 0;"], "SrcStart": 2927}, {"FileMD5": "87527097900edf976ffa31138e4c5ff9.c", "FileName": "crypto/x509/x509_vfy.c", "Line": 116, "Tip": "<b>x</b> is used as the 1st parameter in function <b>X509_check_purpose</b> (<b>x</b> can be null)", "SrcLines": [" * matching issuer and subject names (i.e., the cert being self-issued) and any", " * present authority key identifier matching the subject key identifier, etc.", " */", "static int cert_self_signed(X509 *x)", "{", "    if (X509_check_purpose(x, -1, 0) != 1)", "        return 0;", "    if (x->ex_flags & EXFLAG_SS)", "        return 1;", "    else"], "SrcStart": 111}, {"FileMD5": "c1d07122801b927b8b3769e6b29a0184.c", "FileName": "crypto/x509v3/v3_purp.c", "Line": 85, "Tip": "Load value from <b>x-&gt;ex_flags</b>", "SrcLines": ["{", "    int idx;", "    const X509_PURPOSE *pt;", "", "    x509v3_cache_extensions(x);", "    if (x->ex_flags & EXFLAG_INVALID)", "        return -1;", "", "    /* Return if side-effect only call */", "    if (id == -1)"], "SrcStart": 80}], "Review": 80, "Time": 1630075710000, "DocID": "PE0001", "File": "crypto/x509v3/v3_purp.c", "Line": 85}, {"HashID": "757437575034ce14415eaa5a24f02b0e", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "c1d07122801b927b8b3769e6b29a0184.c", "FileName": "crypto/x509v3/v3_purp.c", "Line": 122, "Tip": "Return <b>null</b> to caller", "SrcLines": ["    if (idx < 0)", "        return NULL;", "    if (idx < (int)X509_PURPOSE_COUNT)", "        return xstandard + idx;", "    return sk_X509_PURPOSE_value(xptable, idx - X509_PURPOSE_COUNT);", "}", "", "int X509_PURPOSE_get_by_sname(const char *sname)", "{", "    int i;"], "SrcStart": 117}, {"FileMD5": "c1d07122801b927b8b3769e6b29a0184.c", "FileName": "crypto/x509v3/v3_purp.c", "Line": 94, "Tip": "Function <b>X509_PURPOSE_get0</b> executes and stores the return value to <b>pt</b> (<b>pt</b> can be null)", "SrcLines": ["    if (id == -1)", "        return 1;", "    idx = X509_PURPOSE_get_by_id(id);", "    if (idx == -1)", "        return -1;", "    pt = X509_PURPOSE_get0(idx);", "    return pt->check_purpose(pt, x, ca);", "}", "", "int X509_PURPOSE_set(int *p, int purpose)"], "SrcStart": 89}, {"FileMD5": "c1d07122801b927b8b3769e6b29a0184.c", "FileName": "crypto/x509v3/v3_purp.c", "Line": 95, "Tip": "Load value from <b>pt-&gt;check_purpose</b>", "SrcLines": ["        return 1;", "    idx = X509_PURPOSE_get_by_id(id);", "    if (idx == -1)", "        return -1;", "    pt = X509_PURPOSE_get0(idx);", "    return pt->check_purpose(pt, x, ca);", "}", "", "int X509_PURPOSE_set(int *p, int purpose)", "{"], "SrcStart": 90}], "Review": 80, "Time": 1630075710000, "DocID": "PE0001", "File": "crypto/x509v3/v3_purp.c", "Line": 95}, {"HashID": "8cfe5896b9bc4226ee6f18ac556d7a50", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "f2272d8c3c73e81d46873146c8a9a7e1.c", "FileName": "crypto/stack/stack.c", "Line": 390, "Tip": "Return <b>null</b> to caller", "SrcLines": ["void *OPENSSL_sk_value(const OPENSSL_STACK *st, int i)", "{", "    if (st == NULL || i < 0 || i >= st->num)", "        return NULL;", "    return (void *)st->data[i];", "}", "", "void *OPENSSL_sk_set(OPENSSL_STACK *st, int i, const void *data)", "{", "    if (st == NULL || i < 0 || i >= st->num)"], "SrcStart": 385}, {"FileMD5": "9ddc19d042d192d7e7a40939177ad903.h", "FileName": "include/openssl/x509v3.h", "Line": 449, "Tip": "Return the return value of function <b>OPENSSL_sk_value</b> to caller", "SrcLines": ["# define X509V3_ADD_REPLACE_EXISTING     3L", "# define X509V3_ADD_KEEP_EXISTING        4L", "# define X509V3_ADD_DELETE               5L", "# define X509V3_ADD_SILENT               0x10", "", "DEFINE_STACK_OF(X509_PURPOSE)", "", "DECLARE_ASN1_FUNCTIONS(BASIC_CONSTRAINTS)", "", "DECLARE_ASN1_FUNCTIONS(SXNET)"], "SrcStart": 444}, {"FileMD5": "c1d07122801b927b8b3769e6b29a0184.c", "FileName": "crypto/x509v3/v3_purp.c", "Line": 121, "Tip": "Function <b>sk_X509_PURPOSE_value</b> executes and returns", "SrcLines": ["{", "    if (idx < 0)", "        return NULL;", "    if (idx < (int)X509_PURPOSE_COUNT)", "        return xstandard + idx;", "    return sk_X509_PURPOSE_value(xptable, idx - X509_PURPOSE_COUNT);", "}", "", "int X509_PURPOSE_get_by_sname(const char *sname)", "{"], "SrcStart": 116}, {"FileMD5": "c1d07122801b927b8b3769e6b29a0184.c", "FileName": "crypto/x509v3/v3_purp.c", "Line": 122, "Tip": "Return the return value of function <b>sk_X509_PURPOSE_value</b> to caller (The return value can be null)", "SrcLines": ["    if (idx < 0)", "        return NULL;", "    if (idx < (int)X509_PURPOSE_COUNT)", "        return xstandard + idx;", "    return sk_X509_PURPOSE_value(xptable, idx - X509_PURPOSE_COUNT);", "}", "", "int X509_PURPOSE_get_by_sname(const char *sname)", "{", "    int i;"], "SrcStart": 117}, {"FileMD5": "c1d07122801b927b8b3769e6b29a0184.c", "FileName": "crypto/x509v3/v3_purp.c", "Line": 174, "Tip": "Function <b>X509_PURPOSE_get0</b> executes and stores the return value to <b>ptmp</b> (<b>ptmp</b> can be null)", "SrcLines": ["            X509V3err(X509V3_F_X509_PURPOSE_ADD, ERR_R_MALLOC_FAILURE);", "            return 0;", "        }", "        ptmp->flags = X509_PURPOSE_DYNAMIC;", "    } else", "        ptmp = X509_PURPOSE_get0(idx);", "", "    /* OPENSSL_free existing name if dynamic */", "    if (ptmp->flags & X509_PURPOSE_DYNAMIC_NAME) {", "        OPENSSL_free(ptmp->name);"], "SrcStart": 169}, {"FileMD5": "c1d07122801b927b8b3769e6b29a0184.c", "FileName": "crypto/x509v3/v3_purp.c", "Line": 177, "Tip": "Load value from <b>ptmp-&gt;flags</b>", "SrcLines": ["        ptmp->flags = X509_PURPOSE_DYNAMIC;", "    } else", "        ptmp = X509_PURPOSE_get0(idx);", "", "    /* OPENSSL_free existing name if dynamic */", "    if (ptmp->flags & X509_PURPOSE_DYNAMIC_NAME) {", "        OPENSSL_free(ptmp->name);", "        OPENSSL_free(ptmp->sname);", "    }", "    /* dup supplied name */"], "SrcStart": 172}], "Review": 80, "Time": 1630075710000, "DocID": "PE0001", "File": "crypto/x509v3/v3_purp.c", "Line": 177}, {"HashID": "9e23873ef072c8c731ec9c551f2ce652", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "f2272d8c3c73e81d46873146c8a9a7e1.c", "FileName": "crypto/stack/stack.c", "Line": 390, "Tip": "Return <b>null</b> to caller", "SrcLines": ["void *OPENSSL_sk_value(const OPENSSL_STACK *st, int i)", "{", "    if (st == NULL || i < 0 || i >= st->num)", "        return NULL;", "    return (void *)st->data[i];", "}", "", "void *OPENSSL_sk_set(OPENSSL_STACK *st, int i, const void *data)", "{", "    if (st == NULL || i < 0 || i >= st->num)"], "SrcStart": 385}, {"FileMD5": "bca7eb7c72dbbf6d7fcda63514d9f27e.h", "FileName": "include/openssl/x509.h", "Line": 99, "Tip": "Return the return value of function <b>OPENSSL_sk_value</b> to caller", "SrcLines": ["", "typedef struct x509_cert_aux_st X509_CERT_AUX;", "", "typedef struct x509_cinf_st X509_CINF;", "", "DEFINE_STACK_OF(X509)", "", "/* This is used for a table of trust checking functions */", "", "typedef struct x509_trust_st {"], "SrcStart": 94}, {"FileMD5": "87527097900edf976ffa31138e4c5ff9.c", "FileName": "crypto/x509/x509_vfy.c", "Line": 487, "Tip": "Function <b>sk_X509_value</b> executes and stores the return value to <b>x</b> (<b>x</b> can be null)", "SrcLines": ["        purpose = ctx->param->purpose;", "    }", "", "    for (i = 0; i < num; i++) {", "        int ret;", "        x = sk_X509_value(ctx->chain, i);", "        if (!(ctx->param->flags & X509_V_FLAG_IGNORE_CRITICAL)", "            && (x->ex_flags & EXFLAG_CRITICAL)) {", "            if (!verify_cb_cert(ctx, x, i,", "                                X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION))"], "SrcStart": 482}, {"FileMD5": "87527097900edf976ffa31138e4c5ff9.c", "FileName": "crypto/x509/x509_vfy.c", "Line": 499, "Tip": "<b>x</b> is used as the 1st parameter in function <b>X509_check_ca</b> (<b>x</b> can be null)", "SrcLines": ["        if (!allow_proxy_certs && (x->ex_flags & EXFLAG_PROXY)) {", "            if (!verify_cb_cert(ctx, x, i,", "                                X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED))", "                return 0;", "        }", "        ret = X509_check_ca(x);", "        switch (must_be_ca) {", "        case -1:", "            if ((ctx->param->flags & X509_V_FLAG_X509_STRICT)", "                && (ret != 1) && (ret != 0)) {"], "SrcStart": 494}, {"FileMD5": "c1d07122801b927b8b3769e6b29a0184.c", "FileName": "crypto/x509v3/v3_purp.c", "Line": 621, "Tip": "<b>x</b> is used as the 1st parameter in function <b>check_ca</b> (<b>x</b> can be null)", "SrcLines": ["", "int X509_check_ca(X509 *x)", "{", "    x509v3_cache_extensions(x);", "", "    return check_ca(x);", "}", "", "/* Check SSL CA: common checks for SSL client and server */", "static int check_ssl_ca(const X509 *x)"], "SrcStart": 616}, {"FileMD5": "c1d07122801b927b8b3769e6b29a0184.c", "FileName": "crypto/x509v3/v3_purp.c", "Line": 582, "Tip": "Load value from <b>x-&gt;ex_flags</b>", "SrcLines": [" */", "", "static int check_ca(const X509 *x)", "{", "    /* keyUsage if present should allow cert signing */", "    if (ku_reject(x, KU_KEY_CERT_SIGN))", "        return 0;", "    if (x->ex_flags & EXFLAG_BCONS) {", "        if (x->ex_flags & EXFLAG_CA)", "            return 1;"], "SrcStart": 577}], "Review": 80, "Time": 1630075710000, "DocID": "PE0001", "File": "crypto/x509v3/v3_purp.c", "Line": 582}]}, "start": 81, "end": 90, "page": 10, "total_pages": 12, "language": "en"}