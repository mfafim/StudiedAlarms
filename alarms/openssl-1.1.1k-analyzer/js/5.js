var data = {"bug_cases": {"BugType": "NULL pointer dereference", "Severity": 12, "CaseList": [{"HashID": "07bfc93b7084dcd5df98dba5b93bb07b", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "f2272d8c3c73e81d46873146c8a9a7e1.c", "FileName": "crypto/stack/stack.c", "Line": 390, "Tip": "Return <b>null</b> to caller", "SrcLines": ["void *OPENSSL_sk_value(const OPENSSL_STACK *st, int i)", "{", "    if (st == NULL || i < 0 || i >= st->num)", "        return NULL;", "    return (void *)st->data[i];", "}", "", "void *OPENSSL_sk_set(OPENSSL_STACK *st, int i, const void *data)", "{", "    if (st == NULL || i < 0 || i >= st->num)"], "SrcStart": 385}, {"FileMD5": "1c7b2ca91bf18554b40a65c950b4a73a.h", "FileName": "crypto/cms/cms_local.h", "Line": 63, "Tip": "Return the return value of function <b>OPENSSL_sk_value</b> to caller", "SrcLines": ["        /* Other types ... */", "        void *otherData;", "    } d;", "};", "", "DEFINE_STACK_OF(CMS_CertificateChoices)", "", "struct CMS_SignedData_st {", "    int32_t version;", "    STACK_OF(X509_ALGOR) *digestAlgorithms;"], "SrcStart": 58}, {"FileMD5": "771c6d725fc643b31b9dcf5f86e2cad5.c", "FileName": "crypto/cms/cms_lib.c", "Line": 391, "Tip": "Function <b>sk_CMS_CertificateChoices_value</b> executes and stores the return value to <b>cch</b> (<b>cch</b> can be null)", "SrcLines": ["    int i;", "    pcerts = cms_get0_certificate_choices(cms);", "    if (!pcerts)", "        return 0;", "    for (i = 0; i < sk_CMS_CertificateChoices_num(*pcerts); i++) {", "        cch = sk_CMS_CertificateChoices_value(*pcerts, i);", "        if (cch->type == CMS_CERTCHOICE_CERT) {", "            if (!X509_cmp(cch->d.certificate, cert)) {", "                CMSerr(CMS_F_CMS_ADD0_CERT,", "                       CMS_R_CERTIFICATE_ALREADY_PRESENT);"], "SrcStart": 386}, {"FileMD5": "771c6d725fc643b31b9dcf5f86e2cad5.c", "FileName": "crypto/cms/cms_lib.c", "Line": 392, "Tip": "Load value from <b>cch-&gt;type</b>", "SrcLines": ["    pcerts = cms_get0_certificate_choices(cms);", "    if (!pcerts)", "        return 0;", "    for (i = 0; i < sk_CMS_CertificateChoices_num(*pcerts); i++) {", "        cch = sk_CMS_CertificateChoices_value(*pcerts, i);", "        if (cch->type == CMS_CERTCHOICE_CERT) {", "            if (!X509_cmp(cch->d.certificate, cert)) {", "                CMSerr(CMS_F_CMS_ADD0_CERT,", "                       CMS_R_CERTIFICATE_ALREADY_PRESENT);", "                return 0;"], "SrcStart": 387}], "Review": 80, "Time": 1630075710000, "DocID": "PE0001", "File": "crypto/cms/cms_lib.c", "Line": 392}, {"HashID": "8ab71df458ebbffe67fd381b43cf24d1", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "f2272d8c3c73e81d46873146c8a9a7e1.c", "FileName": "crypto/stack/stack.c", "Line": 390, "Tip": "Return <b>null</b> to caller", "SrcLines": ["void *OPENSSL_sk_value(const OPENSSL_STACK *st, int i)", "{", "    if (st == NULL || i < 0 || i >= st->num)", "        return NULL;", "    return (void *)st->data[i];", "}", "", "void *OPENSSL_sk_set(OPENSSL_STACK *st, int i, const void *data)", "{", "    if (st == NULL || i < 0 || i >= st->num)"], "SrcStart": 385}, {"FileMD5": "1c7b2ca91bf18554b40a65c950b4a73a.h", "FileName": "crypto/cms/cms_local.h", "Line": 63, "Tip": "Return the return value of function <b>OPENSSL_sk_value</b> to caller", "SrcLines": ["        /* Other types ... */", "        void *otherData;", "    } d;", "};", "", "DEFINE_STACK_OF(CMS_CertificateChoices)", "", "struct CMS_SignedData_st {", "    int32_t version;", "    STACK_OF(X509_ALGOR) *digestAlgorithms;"], "SrcStart": 58}, {"FileMD5": "771c6d725fc643b31b9dcf5f86e2cad5.c", "FileName": "crypto/cms/cms_lib.c", "Line": 489, "Tip": "Function <b>sk_CMS_CertificateChoices_value</b> executes and stores the return value to <b>cch</b> (<b>cch</b> can be null)", "SrcLines": ["    int i;", "    pcerts = cms_get0_certificate_choices(cms);", "    if (!pcerts)", "        return NULL;", "    for (i = 0; i < sk_CMS_CertificateChoices_num(*pcerts); i++) {", "        cch = sk_CMS_CertificateChoices_value(*pcerts, i);", "        if (cch->type == 0) {", "            if (!certs) {", "                certs = sk_X509_new_null();", "                if (!certs)"], "SrcStart": 484}, {"FileMD5": "771c6d725fc643b31b9dcf5f86e2cad5.c", "FileName": "crypto/cms/cms_lib.c", "Line": 490, "Tip": "Load value from <b>cch-&gt;type</b>", "SrcLines": ["    pcerts = cms_get0_certificate_choices(cms);", "    if (!pcerts)", "        return NULL;", "    for (i = 0; i < sk_CMS_CertificateChoices_num(*pcerts); i++) {", "        cch = sk_CMS_CertificateChoices_value(*pcerts, i);", "        if (cch->type == 0) {", "            if (!certs) {", "                certs = sk_X509_new_null();", "                if (!certs)", "                    return NULL;"], "SrcStart": 485}], "Review": 80, "Time": 1630075710000, "DocID": "PE0001", "File": "crypto/cms/cms_lib.c", "Line": 490}, {"HashID": "afd70f0b21c57ee6db3ac050caa99a58", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "f2272d8c3c73e81d46873146c8a9a7e1.c", "FileName": "crypto/stack/stack.c", "Line": 390, "Tip": "Return <b>null</b> to caller", "SrcLines": ["void *OPENSSL_sk_value(const OPENSSL_STACK *st, int i)", "{", "    if (st == NULL || i < 0 || i >= st->num)", "        return NULL;", "    return (void *)st->data[i];", "}", "", "void *OPENSSL_sk_set(OPENSSL_STACK *st, int i, const void *data)", "{", "    if (st == NULL || i < 0 || i >= st->num)"], "SrcStart": 385}, {"FileMD5": "66d30a6d1dbec516109dbd0b88e6a708.h", "FileName": "include/openssl/cms.h", "Line": 36, "Tip": "Return the return value of function <b>OPENSSL_sk_value</b> to caller", "SrcLines": ["typedef struct CMS_OtherKeyAttribute_st CMS_OtherKeyAttribute;", "", "DEFINE_STACK_OF(CMS_SignerInfo)", "DEFINE_STACK_OF(CMS_RecipientEncryptedKey)", "DEFINE_STACK_OF(CMS_RecipientInfo)", "DEFINE_STACK_OF(CMS_RevocationInfoChoice)", "DECLARE_ASN1_FUNCTIONS(CMS_ContentInfo)", "DECLARE_ASN1_FUNCTIONS(CMS_ReceiptRequest)", "DECLARE_ASN1_PRINT_FUNCTION(CMS_ContentInfo)", ""], "SrcStart": 31}, {"FileMD5": "771c6d725fc643b31b9dcf5f86e2cad5.c", "FileName": "crypto/cms/cms_lib.c", "Line": 517, "Tip": "Function <b>sk_CMS_RevocationInfoChoice_value</b> executes and stores the return value to <b>rch</b> (<b>rch</b> can be null)", "SrcLines": ["    int i;", "    pcrls = cms_get0_revocation_choices(cms);", "    if (!pcrls)", "        return NULL;", "    for (i = 0; i < sk_CMS_RevocationInfoChoice_num(*pcrls); i++) {", "        rch = sk_CMS_RevocationInfoChoice_value(*pcrls, i);", "        if (rch->type == 0) {", "            if (!crls) {", "                crls = sk_X509_CRL_new_null();", "                if (!crls)"], "SrcStart": 512}, {"FileMD5": "771c6d725fc643b31b9dcf5f86e2cad5.c", "FileName": "crypto/cms/cms_lib.c", "Line": 518, "Tip": "Load value from <b>rch-&gt;type</b>", "SrcLines": ["    pcrls = cms_get0_revocation_choices(cms);", "    if (!pcrls)", "        return NULL;", "    for (i = 0; i < sk_CMS_RevocationInfoChoice_num(*pcrls); i++) {", "        rch = sk_CMS_RevocationInfoChoice_value(*pcrls, i);", "        if (rch->type == 0) {", "            if (!crls) {", "                crls = sk_X509_CRL_new_null();", "                if (!crls)", "                    return NULL;"], "SrcStart": 513}], "Review": 80, "Time": 1630075710000, "DocID": "PE0001", "File": "crypto/cms/cms_lib.c", "Line": 518}, {"HashID": "bda08b0689c14141daa604372b749e5b", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "f2272d8c3c73e81d46873146c8a9a7e1.c", "FileName": "crypto/stack/stack.c", "Line": 390, "Tip": "Return <b>null</b> to caller", "SrcLines": ["void *OPENSSL_sk_value(const OPENSSL_STACK *st, int i)", "{", "    if (st == NULL || i < 0 || i >= st->num)", "        return NULL;", "    return (void *)st->data[i];", "}", "", "void *OPENSSL_sk_set(OPENSSL_STACK *st, int i, const void *data)", "{", "    if (st == NULL || i < 0 || i >= st->num)"], "SrcStart": 385}, {"FileMD5": "66d30a6d1dbec516109dbd0b88e6a708.h", "FileName": "include/openssl/cms.h", "Line": 33, "Tip": "Return the return value of function <b>OPENSSL_sk_value</b> to caller", "SrcLines": ["typedef struct CMS_ReceiptRequest_st CMS_ReceiptRequest;", "typedef struct CMS_Receipt_st CMS_Receipt;", "typedef struct CMS_RecipientEncryptedKey_st CMS_RecipientEncryptedKey;", "typedef struct CMS_OtherKeyAttribute_st CMS_OtherKeyAttribute;", "", "DEFINE_STACK_OF(CMS_SignerInfo)", "DEFINE_STACK_OF(CMS_RecipientEncryptedKey)", "DEFINE_STACK_OF(CMS_RecipientInfo)", "DEFINE_STACK_OF(CMS_RevocationInfoChoice)", "DECLARE_ASN1_FUNCTIONS(CMS_ContentInfo)"], "SrcStart": 28}, {"FileMD5": "ea1fc5af4400615bc9fd52ae4af80773.c", "FileName": "crypto/cms/cms_sd.c", "Line": 506, "Tip": "Function <b>sk_CMS_SignerInfo_value</b> executes and stores the return value to <b>si</b> (<b>si</b> can be null)", "SrcLines": ["    sd = cms_get0_signed(cms);", "    if (!sd)", "        return -1;", "    certs = sd->certificates;", "    for (i = 0; i < sk_CMS_SignerInfo_num(sd->signerInfos); i++) {", "        si = sk_CMS_SignerInfo_value(sd->signerInfos, i);", "        if (si->signer)", "            continue;", "", "        for (j = 0; j < sk_X509_num(scerts); j++) {"], "SrcStart": 501}, {"FileMD5": "ea1fc5af4400615bc9fd52ae4af80773.c", "FileName": "crypto/cms/cms_sd.c", "Line": 507, "Tip": "Load value from <b>si-&gt;signer</b>", "SrcLines": ["    if (!sd)", "        return -1;", "    certs = sd->certificates;", "    for (i = 0; i < sk_CMS_SignerInfo_num(sd->signerInfos); i++) {", "        si = sk_CMS_SignerInfo_value(sd->signerInfos, i);", "        if (si->signer)", "            continue;", "", "        for (j = 0; j < sk_X509_num(scerts); j++) {", "            x = sk_X509_value(scerts, j);"], "SrcStart": 502}], "Review": 80, "Time": 1630075710000, "DocID": "PE0001", "File": "crypto/cms/cms_sd.c", "Line": 507}, {"HashID": "b27ec900ce24ed2c380b43a5ee0c9e34", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "f2272d8c3c73e81d46873146c8a9a7e1.c", "FileName": "crypto/stack/stack.c", "Line": 390, "Tip": "Return <b>null</b> to caller", "SrcLines": ["void *OPENSSL_sk_value(const OPENSSL_STACK *st, int i)", "{", "    if (st == NULL || i < 0 || i >= st->num)", "        return NULL;", "    return (void *)st->data[i];", "}", "", "void *OPENSSL_sk_set(OPENSSL_STACK *st, int i, const void *data)", "{", "    if (st == NULL || i < 0 || i >= st->num)"], "SrcStart": 385}, {"FileMD5": "2b203c92301ff86205ad0f7aad32b82a.h", "FileName": "include/openssl/conf.h", "Line": 30, "Tip": "Return the return value of function <b>OPENSSL_sk_value</b> to caller", "SrcLines": ["    char *section;", "    char *name;", "    char *value;", "} CONF_VALUE;", "", "DEFINE_STACK_OF(CONF_VALUE)", "DEFINE_LHASH_OF(CONF_VALUE);", "", "struct conf_st;", "struct conf_method_st;"], "SrcStart": 25}, {"FileMD5": "a10e320124fa156a2d51e51a52c177ce.c", "FileName": "crypto/conf/conf_api.c", "Line": 178, "Tip": "Function <b>sk_CONF_VALUE_value</b> executes and stores the return value to <b>vv</b> (<b>vv</b> can be null)", "SrcLines": ["    if (a->name != NULL)", "        return;", "", "    sk = (STACK_OF(CONF_VALUE) *)a->value;", "    for (i = sk_CONF_VALUE_num(sk) - 1; i >= 0; i--) {", "        vv = sk_CONF_VALUE_value(sk, i);", "        OPENSSL_free(vv->value);", "        OPENSSL_free(vv->name);", "        OPENSSL_free(vv);", "    }"], "SrcStart": 173}, {"FileMD5": "a10e320124fa156a2d51e51a52c177ce.c", "FileName": "crypto/conf/conf_api.c", "Line": 180, "Tip": "Load value from <b>vv-&gt;name</b>", "SrcLines": ["", "    sk = (STACK_OF(CONF_VALUE) *)a->value;", "    for (i = sk_CONF_VALUE_num(sk) - 1; i >= 0; i--) {", "        vv = sk_CONF_VALUE_value(sk, i);", "        OPENSSL_free(vv->value);", "        OPENSSL_free(vv->name);", "        OPENSSL_free(vv);", "    }", "    sk_CONF_VALUE_free(sk);", "    OPENSSL_free(a->section);"], "SrcStart": 175}], "Review": 80, "Time": 1630075710000, "DocID": "PE0001", "File": "crypto/conf/conf_api.c", "Line": 180}, {"HashID": "6a9e8ad35cc4c720148954ad58dd7187", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "f2272d8c3c73e81d46873146c8a9a7e1.c", "FileName": "crypto/stack/stack.c", "Line": 390, "Tip": "Return <b>null</b> to caller", "SrcLines": ["void *OPENSSL_sk_value(const OPENSSL_STACK *st, int i)", "{", "    if (st == NULL || i < 0 || i >= st->num)", "        return NULL;", "    return (void *)st->data[i];", "}", "", "void *OPENSSL_sk_set(OPENSSL_STACK *st, int i, const void *data)", "{", "    if (st == NULL || i < 0 || i >= st->num)"], "SrcStart": 385}, {"FileMD5": "2b203c92301ff86205ad0f7aad32b82a.h", "FileName": "include/openssl/conf.h", "Line": 55, "Tip": "Return the return value of function <b>OPENSSL_sk_value</b> to caller", "SrcLines": ["/* Module definitions */", "", "typedef struct conf_imodule_st CONF_IMODULE;", "typedef struct conf_module_st CONF_MODULE;", "", "DEFINE_STACK_OF(CONF_MODULE)", "DEFINE_STACK_OF(CONF_IMODULE)", "", "/* DSO module function typedefs */", "typedef int conf_init_func (CONF_IMODULE *md, const CONF *cnf);"], "SrcStart": 50}, {"FileMD5": "5dd735ec0b4f29eda31330060b784730.c", "FileName": "crypto/conf/conf_mod.c", "Line": 366, "Tip": "Function <b>sk_CONF_MODULE_value</b> executes and stores the return value to <b>md</b> (<b>md</b> can be null)", "SrcLines": ["    int i;", "    CONF_MODULE *md;", "    CONF_modules_finish();", "    /* unload modules in reverse order */", "    for (i = sk_CONF_MODULE_num(supported_modules) - 1; i >= 0; i--) {", "        md = sk_CONF_MODULE_value(supported_modules, i);", "        /* If static or in use and 'all' not set ignore it */", "        if (((md->links > 0) || !md->dso) && !all)", "            continue;", "        /* Since we're working in reverse this is OK */"], "SrcStart": 361}, {"FileMD5": "5dd735ec0b4f29eda31330060b784730.c", "FileName": "crypto/conf/conf_mod.c", "Line": 368, "Tip": "Load value from <b>md-&gt;links</b>", "SrcLines": ["    CONF_modules_finish();", "    /* unload modules in reverse order */", "    for (i = sk_CONF_MODULE_num(supported_modules) - 1; i >= 0; i--) {", "        md = sk_CONF_MODULE_value(supported_modules, i);", "        /* If static or in use and 'all' not set ignore it */", "        if (((md->links > 0) || !md->dso) && !all)", "            continue;", "        /* Since we're working in reverse this is OK */", "        (void)sk_CONF_MODULE_delete(supported_modules, i);", "        module_free(md);"], "SrcStart": 363}], "Review": 80, "Time": 1630075710000, "DocID": "PE0001", "File": "crypto/conf/conf_mod.c", "Line": 368}, {"HashID": "ae21bfdedaf05ad4e86f18605ed89da5", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "db1c317a234be5e4fef5d667ae66513e.c", "FileName": "crypto/cms/cms_kari.c", "Line": 206, "Tip": "<b>null</b> is used as the 2nd parameter in function <b>EVP_CipherUpdate</b>", "SrcLines": ["        goto err;", "    /* Set KEK in context */", "    if (!EVP_CipherInit_ex(kari->ctx, NULL, NULL, kek, NULL, enc))", "        goto err;", "    /* obtain output length of ciphered key */", "    if (!EVP_CipherUpdate(kari->ctx, NULL, &outlen, in, inlen))", "        goto err;", "    out = OPENSSL_malloc(outlen);", "    if (out == NULL)", "        goto err;"], "SrcStart": 201}, {"FileMD5": "4700f50a52919d678cca3bf3f075d675.c", "FileName": "crypto/evp/evp_enc.c", "Line": 216, "Tip": "<b>out</b> is used as the 2nd parameter in function <b>EVP_DecryptUpdate</b> (<b>out</b> can be null)", "SrcLines": ["                     const unsigned char *in, int inl)", "{", "    if (ctx->encrypt)", "        return EVP_EncryptUpdate(ctx, out, outl, in, inl);", "    else", "        return EVP_DecryptUpdate(ctx, out, outl, in, inl);", "}", "", "int EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)", "{"], "SrcStart": 211}, {"FileMD5": "4700f50a52919d678cca3bf3f075d675.c", "FileName": "crypto/evp/evp_enc.c", "Line": 532, "Tip": "Copy data to <b>out</b> (<b>out</b> can be null)", "SrcLines": ["         */", "        if ((inl & ~(b - 1)) > INT_MAX - b) {", "            EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_OUTPUT_WOULD_OVERFLOW);", "            return 0;", "        }", "        memcpy(out, ctx->final, b);", "        out += b;", "        fix_len = 1;", "    } else", "        fix_len = 0;"], "SrcStart": 527}], "Review": 80, "Time": 1630075710000, "DocID": "PE0001", "File": "crypto/evp/evp_enc.c", "Line": 532}, {"HashID": "fc1d39915605fdb672f04e36678de06f", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "db1c317a234be5e4fef5d667ae66513e.c", "FileName": "crypto/cms/cms_kari.c", "Line": 206, "Tip": "<b>null</b> is used as the 2nd parameter in function <b>EVP_CipherUpdate</b>", "SrcLines": ["        goto err;", "    /* Set KEK in context */", "    if (!EVP_CipherInit_ex(kari->ctx, NULL, NULL, kek, NULL, enc))", "        goto err;", "    /* obtain output length of ciphered key */", "    if (!EVP_CipherUpdate(kari->ctx, NULL, &outlen, in, inlen))", "        goto err;", "    out = OPENSSL_malloc(outlen);", "    if (out == NULL)", "        goto err;"], "SrcStart": 201}, {"FileMD5": "4700f50a52919d678cca3bf3f075d675.c", "FileName": "crypto/evp/evp_enc.c", "Line": 216, "Tip": "<b>out</b> is used as the 2nd parameter in function <b>EVP_DecryptUpdate</b> (<b>out</b> can be null)", "SrcLines": ["                     const unsigned char *in, int inl)", "{", "    if (ctx->encrypt)", "        return EVP_EncryptUpdate(ctx, out, outl, in, inl);", "    else", "        return EVP_DecryptUpdate(ctx, out, outl, in, inl);", "}", "", "int EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)", "{"], "SrcStart": 211}, {"FileMD5": "4700f50a52919d678cca3bf3f075d675.c", "FileName": "crypto/evp/evp_enc.c", "Line": 528, "Tip": "Select the false branch at this point (<b>(cmpl&amp;(!(b-1)))&gt;(2147483647-b)</b> is false)", "SrcLines": ["         * inl & ~(b - 1)", "         * Since final_used has been set then the final output length is:", "         * (inl & ~(b - 1)) + b", "         * This must never exceed INT_MAX", "         */", "        if ((inl & ~(b - 1)) > INT_MAX - b) {", "            EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_OUTPUT_WOULD_OVERFLOW);", "            return 0;", "        }", "        memcpy(out, ctx->final, b);"], "SrcStart": 523}, {"FileMD5": "4700f50a52919d678cca3bf3f075d675.c", "FileName": "crypto/evp/evp_enc.c", "Line": 548, "Tip": "Copy data from <b>&amp;(out[outl])</b> (<b>&amp;(out[outl])</b> can be null)", "SrcLines": ["     * copy of this last block", "     */", "    if (b > 1 && !ctx->buf_len) {", "        *outl -= b;", "        ctx->final_used = 1;", "        memcpy(ctx->final, &out[*outl], b);", "    } else", "        ctx->final_used = 0;", "", "    if (fix_len)"], "SrcStart": 543}], "Review": 80, "Time": 1630075710000, "DocID": "PE0001", "File": "crypto/evp/evp_enc.c", "Line": 548}, {"HashID": "b5c9938c796efa9db0ae5a3f9cfe2980", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "5f3554e43b4f64ec7a5da69f173fea6a.c", "FileName": "crypto/evp/evp_lib.c", "Line": 463, "Tip": "Return <b>null</b> to caller", "SrcLines": ["const EVP_MD *EVP_MD_CTX_md(const EVP_MD_CTX *ctx)", "{", "    if (!ctx)", "        return NULL;", "    return ctx->digest;", "}", "", "EVP_PKEY_CTX *EVP_MD_CTX_pkey_ctx(const EVP_MD_CTX *ctx)", "{", "    return ctx->pctx;"], "SrcStart": 458}, {"FileMD5": "771c6d725fc643b31b9dcf5f86e2cad5.c", "FileName": "crypto/cms/cms_lib.c", "Line": 329, "Tip": "The return value of function <b>EVP_MD_CTX_md</b> is used as the 1st parameter in function <b>EVP_MD_type</b> (the return value of function <b>EVP_MD_CTX_md</b> can be null)", "SrcLines": ["            CMSerr(CMS_F_CMS_DIGESTALGORITHM_FIND_CTX,", "                   CMS_R_NO_MATCHING_DIGEST);", "            return 0;", "        }", "        BIO_get_md_ctx(chain, &mtmp);", "        if (EVP_MD_CTX_type(mtmp) == nid", "            /*", "             * Workaround for broken implementations that use signature", "             * algorithm OID instead of digest.", "             */"], "SrcStart": 324}, {"FileMD5": "5f3554e43b4f64ec7a5da69f173fea6a.c", "FileName": "crypto/evp/evp_lib.c", "Line": 312, "Tip": "Load value from <b>md-&gt;type</b>", "SrcLines": ["    return md->block_size;", "}", "", "int EVP_MD_type(const EVP_MD *md)", "{", "    return md->type;", "}", "", "int EVP_MD_pkey_type(const EVP_MD *md)", "{"], "SrcStart": 307}], "Review": 80, "Time": 1630075710000, "DocID": "PE0001", "File": "crypto/evp/evp_lib.c", "Line": 312}, {"HashID": "a773321234f1b00e7cd05e8efe19b7b0", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "5f3554e43b4f64ec7a5da69f173fea6a.c", "FileName": "crypto/evp/evp_lib.c", "Line": 463, "Tip": "Return <b>null</b> to caller", "SrcLines": ["const EVP_MD *EVP_MD_CTX_md(const EVP_MD_CTX *ctx)", "{", "    if (!ctx)", "        return NULL;", "    return ctx->digest;", "}", "", "EVP_PKEY_CTX *EVP_MD_CTX_pkey_ctx(const EVP_MD_CTX *ctx)", "{", "    return ctx->pctx;"], "SrcStart": 458}, {"FileMD5": "771c6d725fc643b31b9dcf5f86e2cad5.c", "FileName": "crypto/cms/cms_lib.c", "Line": 334, "Tip": "The return value of function <b>EVP_MD_CTX_md</b> is used as the 1st parameter in function <b>EVP_MD_pkey_type</b> (the return value of function <b>EVP_MD_CTX_md</b> can be null)", "SrcLines": ["        if (EVP_MD_CTX_type(mtmp) == nid", "            /*", "             * Workaround for broken implementations that use signature", "             * algorithm OID instead of digest.", "             */", "            || EVP_MD_pkey_type(EVP_MD_CTX_md(mtmp)) == nid)", "            return EVP_MD_CTX_copy_ex(mctx, mtmp);", "        chain = BIO_next(chain);", "    }", "}"], "SrcStart": 329}, {"FileMD5": "5f3554e43b4f64ec7a5da69f173fea6a.c", "FileName": "crypto/evp/evp_lib.c", "Line": 317, "Tip": "Load value from <b>md-&gt;pkey_type</b>", "SrcLines": ["    return md->type;", "}", "", "int EVP_MD_pkey_type(const EVP_MD *md)", "{", "    return md->pkey_type;", "}", "", "int EVP_MD_size(const EVP_MD *md)", "{"], "SrcStart": 312}], "Review": 80, "Time": 1630075710000, "DocID": "PE0001", "File": "crypto/evp/evp_lib.c", "Line": 317}]}, "start": 31, "end": 40, "page": 5, "total_pages": 12, "language": "en"}