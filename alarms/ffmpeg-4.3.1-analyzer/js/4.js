var data = {"bug_cases": {"BugType": "NULL pointer dereference", "Severity": 12, "CaseList": [{"HashID": "2a964eedaa122f19a1b54d46c9f5ed50", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "ff664eb4f297e90ee2c59faab7d4dba3.c", "FileName": "libavcodec/ccaption_dec.c", "Line": 398, "Tip": "Return <b>null</b> to caller", "SrcLines": ["        // use active screen", "        return ctx->screen + ctx->active_screen;", "    }", "    /* It was never an option */", "    return NULL;", "}", "", "static void roll_up(CCaptionSubContext *ctx)", "{", "    struct Screen *screen;"], "SrcStart": 393}, {"FileMD5": "ff664eb4f297e90ee2c59faab7d4dba3.c", "FileName": "libavcodec/ccaption_dec.c", "Line": 408, "Tip": "Function <b>get_writing_screen</b> executes and stores the return value to <b>screen</b> (<b>screen</b> can be null)", "SrcLines": ["    int i, keep_lines;", "", "    if (ctx->mode == CCMODE_TEXT)", "        return;", "", "    screen = get_writing_screen(ctx);", "", "    /* +1 signify cursor_row starts from 0", "     * Can't keep lines less then row cursor pos", "     */"], "SrcStart": 403}, {"FileMD5": "ff664eb4f297e90ee2c59faab7d4dba3.c", "FileName": "libavcodec/ccaption_dec.c", "Line": 418, "Tip": "Load value from <b>screen-&gt;row_used</b>", "SrcLines": ["    keep_lines = FFMIN(ctx->cursor_row + 1, ctx->rollup);", "", "    for (i = 0; i < SCREEN_ROWS; i++) {", "        if (i > ctx->cursor_row - keep_lines && i <= ctx->cursor_row)", "            continue;", "        UNSET_FLAG(screen->row_used, i);", "    }", "", "    for (i = 0; i < keep_lines && screen->row_used; i++) {", "        const int i_row = ctx->cursor_row - keep_lines + i + 1;"], "SrcStart": 413}], "Review": 80, "Time": 1629218470000, "DocID": "PE0001", "File": "libavcodec/ccaption_dec.c", "Line": 418}, {"HashID": "258af516747138f2ba85770b8431f0cb", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "ff664eb4f297e90ee2c59faab7d4dba3.c", "FileName": "libavcodec/ccaption_dec.c", "Line": 398, "Tip": "Return <b>null</b> to caller", "SrcLines": ["        // use active screen", "        return ctx->screen + ctx->active_screen;", "    }", "    /* It was never an option */", "    return NULL;", "}", "", "static void roll_up(CCaptionSubContext *ctx)", "{", "    struct Screen *screen;"], "SrcStart": 393}, {"FileMD5": "ff664eb4f297e90ee2c59faab7d4dba3.c", "FileName": "libavcodec/ccaption_dec.c", "Line": 408, "Tip": "Function <b>get_writing_screen</b> executes and stores the return value to <b>screen</b> (<b>screen</b> can be null)", "SrcLines": ["    int i, keep_lines;", "", "    if (ctx->mode == CCMODE_TEXT)", "        return;", "", "    screen = get_writing_screen(ctx);", "", "    /* +1 signify cursor_row starts from 0", "     * Can't keep lines less then row cursor pos", "     */"], "SrcStart": 403}, {"FileMD5": "ff664eb4f297e90ee2c59faab7d4dba3.c", "FileName": "libavcodec/ccaption_dec.c", "Line": 421, "Tip": "Load value from <b>screen-&gt;row_used</b>", "SrcLines": ["        if (i > ctx->cursor_row - keep_lines && i <= ctx->cursor_row)", "            continue;", "        UNSET_FLAG(screen->row_used, i);", "    }", "", "    for (i = 0; i < keep_lines && screen->row_used; i++) {", "        const int i_row = ctx->cursor_row - keep_lines + i + 1;", "", "        memcpy(screen->characters[i_row], screen->characters[i_row+1], SCREEN_COLUMNS);", "        memcpy(screen->colors[i_row], screen->colors[i_row+1], SCREEN_COLUMNS);"], "SrcStart": 416}], "Review": 80, "Time": 1629218470000, "DocID": "PE0001", "File": "libavcodec/ccaption_dec.c", "Line": 421}, {"HashID": "f10bbb38909a32bc2290ff660197b093", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "ff664eb4f297e90ee2c59faab7d4dba3.c", "FileName": "libavcodec/ccaption_dec.c", "Line": 398, "Tip": "Return <b>null</b> to caller", "SrcLines": ["        // use active screen", "        return ctx->screen + ctx->active_screen;", "    }", "    /* It was never an option */", "    return NULL;", "}", "", "static void roll_up(CCaptionSubContext *ctx)", "{", "    struct Screen *screen;"], "SrcStart": 393}, {"FileMD5": "ff664eb4f297e90ee2c59faab7d4dba3.c", "FileName": "libavcodec/ccaption_dec.c", "Line": 408, "Tip": "Function <b>get_writing_screen</b> executes and stores the return value to <b>screen</b> (<b>screen</b> can be null)", "SrcLines": ["    int i, keep_lines;", "", "    if (ctx->mode == CCMODE_TEXT)", "        return;", "", "    screen = get_writing_screen(ctx);", "", "    /* +1 signify cursor_row starts from 0", "     * Can't keep lines less then row cursor pos", "     */"], "SrcStart": 403}, {"FileMD5": "ff664eb4f297e90ee2c59faab7d4dba3.c", "FileName": "libavcodec/ccaption_dec.c", "Line": 428, "Tip": "Load value from <b>screen-&gt;row_used</b>", "SrcLines": ["", "        memcpy(screen->characters[i_row], screen->characters[i_row+1], SCREEN_COLUMNS);", "        memcpy(screen->colors[i_row], screen->colors[i_row+1], SCREEN_COLUMNS);", "        memcpy(screen->fonts[i_row], screen->fonts[i_row+1], SCREEN_COLUMNS);", "        memcpy(screen->charsets[i_row], screen->charsets[i_row+1], SCREEN_COLUMNS);", "        if (CHECK_FLAG(screen->row_used, i_row + 1))", "            SET_FLAG(screen->row_used, i_row);", "    }", "", "    UNSET_FLAG(screen->row_used, ctx->cursor_row);"], "SrcStart": 423}], "Review": 80, "Time": 1629218470000, "DocID": "PE0001", "File": "libavcodec/ccaption_dec.c", "Line": 428}, {"HashID": "fce3c40fbcbd70a76d17559f6fabb393", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "ff664eb4f297e90ee2c59faab7d4dba3.c", "FileName": "libavcodec/ccaption_dec.c", "Line": 398, "Tip": "Return <b>null</b> to caller", "SrcLines": ["        // use active screen", "        return ctx->screen + ctx->active_screen;", "    }", "    /* It was never an option */", "    return NULL;", "}", "", "static void roll_up(CCaptionSubContext *ctx)", "{", "    struct Screen *screen;"], "SrcStart": 393}, {"FileMD5": "ff664eb4f297e90ee2c59faab7d4dba3.c", "FileName": "libavcodec/ccaption_dec.c", "Line": 408, "Tip": "Function <b>get_writing_screen</b> executes and stores the return value to <b>screen</b> (<b>screen</b> can be null)", "SrcLines": ["    int i, keep_lines;", "", "    if (ctx->mode == CCMODE_TEXT)", "        return;", "", "    screen = get_writing_screen(ctx);", "", "    /* +1 signify cursor_row starts from 0", "     * Can't keep lines less then row cursor pos", "     */"], "SrcStart": 403}, {"FileMD5": "ff664eb4f297e90ee2c59faab7d4dba3.c", "FileName": "libavcodec/ccaption_dec.c", "Line": 432, "Tip": "Load value from <b>screen-&gt;row_used</b>", "SrcLines": ["        memcpy(screen->charsets[i_row], screen->charsets[i_row+1], SCREEN_COLUMNS);", "        if (CHECK_FLAG(screen->row_used, i_row + 1))", "            SET_FLAG(screen->row_used, i_row);", "    }", "", "    UNSET_FLAG(screen->row_used, ctx->cursor_row);", "}", "", "static int capture_screen(CCaptionSubContext *ctx)", "{"], "SrcStart": 427}], "Review": 80, "Time": 1629218470000, "DocID": "PE0001", "File": "libavcodec/ccaption_dec.c", "Line": 432}, {"HashID": "e0f28692c33646cc38d22e313eb067dc", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "ff664eb4f297e90ee2c59faab7d4dba3.c", "FileName": "libavcodec/ccaption_dec.c", "Line": 398, "Tip": "Return <b>null</b> to caller", "SrcLines": ["        // use active screen", "        return ctx->screen + ctx->active_screen;", "    }", "    /* It was never an option */", "    return NULL;", "}", "", "static void roll_up(CCaptionSubContext *ctx)", "{", "    struct Screen *screen;"], "SrcStart": 393}, {"FileMD5": "ff664eb4f297e90ee2c59faab7d4dba3.c", "FileName": "libavcodec/ccaption_dec.c", "Line": 540, "Tip": "Function <b>get_writing_screen</b> executes and stores the return value to <b>screen</b> (<b>screen</b> can be null)", "SrcLines": ["}", "", "static void handle_textattr(CCaptionSubContext *ctx, uint8_t hi, uint8_t lo)", "{", "    int i = lo - 0x20;", "    struct Screen *screen = get_writing_screen(ctx);", "", "    if (i >= 32)", "        return;", ""], "SrcStart": 535}, {"FileMD5": "ff664eb4f297e90ee2c59faab7d4dba3.c", "FileName": "libavcodec/ccaption_dec.c", "Line": 548, "Tip": "Load value from <b>screen-&gt;row_used</b>", "SrcLines": ["        return;", "", "    ctx->cursor_color = pac2_attribs[i][0];", "    ctx->cursor_font = pac2_attribs[i][1];", "", "    SET_FLAG(screen->row_used, ctx->cursor_row);", "    write_char(ctx, screen, ' ');", "}", "", "static void handle_pac(CCaptionSubContext *ctx, uint8_t hi, uint8_t lo)"], "SrcStart": 543}], "Review": 80, "Time": 1629218470000, "DocID": "PE0001", "File": "libavcodec/ccaption_dec.c", "Line": 548}, {"HashID": "4d1778aaaa3b927ca06565180f47cc93", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "ff664eb4f297e90ee2c59faab7d4dba3.c", "FileName": "libavcodec/ccaption_dec.c", "Line": 398, "Tip": "Return <b>null</b> to caller", "SrcLines": ["        // use active screen", "        return ctx->screen + ctx->active_screen;", "    }", "    /* It was never an option */", "    return NULL;", "}", "", "static void roll_up(CCaptionSubContext *ctx)", "{", "    struct Screen *screen;"], "SrcStart": 393}, {"FileMD5": "ff664eb4f297e90ee2c59faab7d4dba3.c", "FileName": "libavcodec/ccaption_dec.c", "Line": 623, "Tip": "Function <b>get_writing_screen</b> executes and stores the return value to <b>screen</b> (<b>screen</b> can be null)", "SrcLines": ["    write_char(ctx, screen, 0);", "}", "", "static void handle_char(CCaptionSubContext *ctx, char hi, char lo, int64_t pts)", "{", "    struct Screen *screen = get_writing_screen(ctx);", "", "    SET_FLAG(screen->row_used, ctx->cursor_row);", "", "    switch (hi) {"], "SrcStart": 618}, {"FileMD5": "ff664eb4f297e90ee2c59faab7d4dba3.c", "FileName": "libavcodec/ccaption_dec.c", "Line": 625, "Tip": "Load value from <b>screen-&gt;row_used</b>", "SrcLines": ["", "static void handle_char(CCaptionSubContext *ctx, char hi, char lo, int64_t pts)", "{", "    struct Screen *screen = get_writing_screen(ctx);", "", "    SET_FLAG(screen->row_used, ctx->cursor_row);", "", "    switch (hi) {", "      case 0x11:", "        ctx->cursor_charset = CCSET_SPECIAL_AMERICAN;"], "SrcStart": 620}], "Review": 80, "Time": 1629218470000, "DocID": "PE0001", "File": "libavcodec/ccaption_dec.c", "Line": 625}, {"HashID": "179a8f63b71259c5c682b794d9bbb3eb", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "2f85f77c52ac687f1143a8c0b39a3d5b.c", "FileName": "libavcodec/encode.c", "Line": 448, "Tip": "<b>null</b> is used as the 2nd parameter in function <b>do_encode</b>", "SrcLines": ["    if (!avctx->internal->buffer_pkt_valid) {", "        int got_packet;", "        int ret;", "        if (!avctx->internal->draining)", "            return AVERROR(EAGAIN);", "        ret = do_encode(avctx, NULL, &got_packet);", "        if (ret < 0)", "            return ret;", "        if (ret >= 0 && !got_packet)", "            return AVERROR_EOF;"], "SrcStart": 443}, {"FileMD5": "2f85f77c52ac687f1143a8c0b39a3d5b.c", "FileName": "libavcodec/encode.c", "Line": 370, "Tip": "<b>frame</b> is used as the 3rd parameter in function <b>avcodec_encode_video2</b> (<b>frame</b> can be null)", "SrcLines": ["", "    av_packet_unref(avctx->internal->buffer_pkt);", "    avctx->internal->buffer_pkt_valid = 0;", "", "    if (avctx->codec_type == AVMEDIA_TYPE_VIDEO) {", "        ret = avcodec_encode_video2(avctx, avctx->internal->buffer_pkt,", "                                    frame, got_packet);", "    } else if (avctx->codec_type == AVMEDIA_TYPE_AUDIO) {", "        ret = avcodec_encode_audio2(avctx, avctx->internal->buffer_pkt,", "                                    frame, got_packet);"], "SrcStart": 365}, {"FileMD5": "2f85f77c52ac687f1143a8c0b39a3d5b.c", "FileName": "libavcodec/encode.c", "Line": 302, "Tip": "Load value from <b>frame-&gt;pts</b>", "SrcLines": ["        avctx->internal->frame_thread_encoder && (avctx->active_thread_type & FF_THREAD_FRAME))", "        ret = ff_thread_video_encode_frame(avctx, avpkt, frame, got_packet_ptr);", "    else {", "        ret = avctx->codec->encode2(avctx, avpkt, frame, got_packet_ptr);", "        if (*got_packet_ptr && !(avctx->codec->capabilities & AV_CODEC_CAP_DELAY))", "            avpkt->pts = avpkt->dts = frame->pts;", "    }", "    av_assert0(ret <= 0);", "", "    emms_c();"], "SrcStart": 297}], "Review": 80, "Time": 1629218470000, "DocID": "PE0001", "File": "libavcodec/encode.c", "Line": 302}, {"HashID": "a7147d2985d21fed012342d77f0056e2", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "2ef10799fbbf3a2451fcf511a603c021.c", "FileName": "libavcodec/filter_units_bsf.c", "Line": 52, "Tip": "Store <b>null</b> to <b>list</b>", "SrcLines": ["", "static int filter_units_make_type_list(const char *list_string,", "                                       CodedBitstreamUnitType **type_list,", "                                       int *nb_types)", "{", "    CodedBitstreamUnitType *list = NULL;", "    int pass, count;", "", "    for (pass = 1; pass <= 2; pass++) {", "        long value, range_start, range_end;"], "SrcStart": 47}, {"FileMD5": "2ef10799fbbf3a2451fcf511a603c021.c", "FileName": "libavcodec/filter_units_bsf.c", "Line": 75, "Tip": "Load value from <b>list</b>", "SrcLines": ["                if (str == value_end)", "                    goto invalid;", "", "                for (value = range_start; value < range_end; value++) {", "                    if (pass == 2)", "                        list[count] = value;", "                    ++count;", "                }", "            } else {", "                if (pass == 2)"], "SrcStart": 70}, {"FileMD5": "2ef10799fbbf3a2451fcf511a603c021.c", "FileName": "libavcodec/filter_units_bsf.c", "Line": 75, "Tip": "Store <b>value</b> to <b>list[i]</b>", "SrcLines": ["                if (str == value_end)", "                    goto invalid;", "", "                for (value = range_start; value < range_end; value++) {", "                    if (pass == 2)", "                        list[count] = value;", "                    ++count;", "                }", "            } else {", "                if (pass == 2)"], "SrcStart": 70}], "Review": 80, "Time": 1629218470000, "DocID": "PE0001", "File": "libavcodec/filter_units_bsf.c", "Line": 75}, {"HashID": "0c95def98fb0424b6090f0629e0a613e", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "2ef10799fbbf3a2451fcf511a603c021.c", "FileName": "libavcodec/filter_units_bsf.c", "Line": 52, "Tip": "Store <b>null</b> to <b>list</b>", "SrcLines": ["", "static int filter_units_make_type_list(const char *list_string,", "                                       CodedBitstreamUnitType **type_list,", "                                       int *nb_types)", "{", "    CodedBitstreamUnitType *list = NULL;", "    int pass, count;", "", "    for (pass = 1; pass <= 2; pass++) {", "        long value, range_start, range_end;"], "SrcStart": 47}, {"FileMD5": "2ef10799fbbf3a2451fcf511a603c021.c", "FileName": "libavcodec/filter_units_bsf.c", "Line": 80, "Tip": "Load value from <b>list</b>", "SrcLines": ["                        list[count] = value;", "                    ++count;", "                }", "            } else {", "                if (pass == 2)", "                    list[count] = value;", "                ++count;", "            }", "            if (*str == '|')", "                ++str;"], "SrcStart": 75}, {"FileMD5": "2ef10799fbbf3a2451fcf511a603c021.c", "FileName": "libavcodec/filter_units_bsf.c", "Line": 80, "Tip": "Store <b>value</b> to <b>list[count]</b>", "SrcLines": ["                        list[count] = value;", "                    ++count;", "                }", "            } else {", "                if (pass == 2)", "                    list[count] = value;", "                ++count;", "            }", "            if (*str == '|')", "                ++str;"], "SrcStart": 75}], "Review": 80, "Time": 1629218470000, "DocID": "PE0001", "File": "libavcodec/filter_units_bsf.c", "Line": 80}, {"HashID": "64cc842fa1610e034dafe5cfa28ae20e", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "4869fefdcd54ba97ec2a5823686ae963.h", "FileName": "libavcodec/get_bits.h", "Line": 628, "Tip": "Select the true branch at this point (<b>buffer==null</b> is true)", "SrcLines": ["                                   int bit_size, int is_le)", "{", "    int buffer_size;", "    int ret = 0;", "", "    if (bit_size >= INT_MAX - FFMAX(7, AV_INPUT_BUFFER_PADDING_SIZE*8) || bit_size < 0 || !buffer) {", "        bit_size    = 0;", "        buffer      = NULL;", "        ret         = AVERROR_INVALIDDATA;", "    }"], "SrcStart": 623}, {"FileMD5": "4869fefdcd54ba97ec2a5823686ae963.h", "FileName": "libavcodec/get_bits.h", "Line": 634, "Tip": "<b>null</b> assigned to <b>buffer</b> reaches here", "SrcLines": ["        bit_size    = 0;", "        buffer      = NULL;", "        ret         = AVERROR_INVALIDDATA;", "    }", "", "    buffer_size = (bit_size + 7) >> 3;", "", "    s->buffer             = buffer;", "    s->size_in_bits       = bit_size;", "    s->size_in_bits_plus8 = bit_size + 8;"], "SrcStart": 629}, {"FileMD5": "4869fefdcd54ba97ec2a5823686ae963.h", "FileName": "libavcodec/get_bits.h", "Line": 636, "Tip": "Store <b>null</b> to <b>s-&gt;buffer</b>", "SrcLines": ["        ret         = AVERROR_INVALIDDATA;", "    }", "", "    buffer_size = (bit_size + 7) >> 3;", "", "    s->buffer             = buffer;", "    s->size_in_bits       = bit_size;", "    s->size_in_bits_plus8 = bit_size + 8;", "    s->buffer_end         = buffer + buffer_size;", "    s->index              = 0;"], "SrcStart": 631}, {"FileMD5": "4869fefdcd54ba97ec2a5823686ae963.h", "FileName": "libavcodec/get_bits.h", "Line": 624, "Tip": "Program reaches the return point, modifying the value <b>s-&gt;buffer</b> to null", "SrcLines": ["    return bit;", "}", "", "static inline int init_get_bits_xe(GetBitContext *s, const uint8_t *buffer,", "                                   int bit_size, int is_le)", "{", "    int buffer_size;", "    int ret = 0;", "", "    if (bit_size >= INT_MAX - FFMAX(7, AV_INPUT_BUFFER_PADDING_SIZE*8) || bit_size < 0 || !buffer) {"], "SrcStart": 619}, {"FileMD5": "4869fefdcd54ba97ec2a5823686ae963.h", "FileName": "libavcodec/get_bits.h", "Line": 665, "Tip": "Function <b>init_get_bits_xe</b> modifies the value <b>s-&gt;buffer</b> to null, where <b>s</b> is used as the 1st parameter (<b>s</b>)", "SrcLines": ["                                int bit_size)", "{", "#ifdef BITSTREAM_READER_LE", "    return init_get_bits_xe(s, buffer, bit_size, 1);", "#else", "    return init_get_bits_xe(s, buffer, bit_size, 0);", "#endif", "}", "", "/**"], "SrcStart": 660}, {"FileMD5": "4869fefdcd54ba97ec2a5823686ae963.h", "FileName": "libavcodec/get_bits.h", "Line": 661, "Tip": "Program reaches the return point, modifying the value <b>s-&gt;buffer</b> to null", "SrcLines": [" * @param bit_size the size of the buffer in bits", " * @return 0 on success, AVERROR_INVALIDDATA if the buffer_size would overflow.", " */", "static inline int init_get_bits(GetBitContext *s, const uint8_t *buffer,", "                                int bit_size)", "{", "#ifdef BITSTREAM_READER_LE", "    return init_get_bits_xe(s, buffer, bit_size, 1);", "#else", "    return init_get_bits_xe(s, buffer, bit_size, 0);"], "SrcStart": 656}, {"FileMD5": "be15b7a0e6aba53449cb33adcbf14544.c", "FileName": "libavcodec/mpegaudiodec_template.c", "Line": 1567, "Tip": "Function <b>init_get_bits</b> modifies the value <b>&amp;(s-&gt;gb)-&gt;buffer</b> to null, where <b>&amp;(s-&gt;gb)</b> is used as the 1st parameter (<b>s</b>)", "SrcLines": ["                           const uint8_t *buf, int buf_size)", "{", "    int i, nb_frames, ch, ret;", "    OUT_INT *samples_ptr;", "", "    init_get_bits(&s->gb, buf + HEADER_SIZE, (buf_size - HEADER_SIZE) * 8);", "", "    if (s->error_protection) {", "        uint16_t crc = get_bits(&s->gb, 16);", "        if (s->err_recognition & AV_EF_CRCCHECK) {"], "SrcStart": 1562}, {"FileMD5": "be15b7a0e6aba53449cb33adcbf14544.c", "FileName": "libavcodec/mpegaudiodec_template.c", "Line": 1605, "Tip": "<b>&amp;(s-&gt;gb.buffer[get_bits_count(s-&gt;gb)&gt;&gt;3])</b> is used as the 2nd parameter in function <b>memmove</b> (<b>&amp;(s-&gt;gb.buffer[get_bits_count(s-&gt;gb)&gt;&gt;3])</b> can be null)", "SrcLines": ["        s->last_buf_size=0;", "        if (s->in_gb.buffer) {", "            align_get_bits(&s->gb);", "            i = (get_bits_left(&s->gb) >> 3) - s->extrasize;", "            if (i >= 0 && i <= BACKSTEP_SIZE) {", "                memmove(s->last_buf, s->gb.buffer + (get_bits_count(&s->gb)>>3), i);", "                s->last_buf_size=i;", "            } else", "                av_log(s->avctx, AV_LOG_ERROR, \"invalid old backstep %d\\n\", i);", "            s->gb           = s->in_gb;"], "SrcStart": 1600}], "Review": 80, "Time": 1629218470000, "DocID": "PE0001", "File": "libavcodec/mpegaudiodec_template.c", "Line": 1605}]}, "start": 21, "end": 30, "page": 4, "total_pages": 9, "language": "en"}