var data = {"bug_cases": {"BugType": "NULL pointer dereference", "Severity": 12, "CaseList": [{"HashID": "b5031989db055c07a6e28e7f0b15b8cd", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "d14766da37af90e60fb96aa3cbdc058f.c", "FileName": "libavfilter/framesync.c", "Line": 262, "Tip": "Store <b>null</b> to <b>rframe</b>", "SrcLines": ["    unsigned need_copy = 0, i;", "    int64_t pts_next;", "    int ret;", "", "    if (!fs->in[in].frame) {", "        *rframe = NULL;", "        return 0;", "    }", "    frame = fs->in[in].frame;", "    if (get) {"], "SrcStart": 257}, {"FileMD5": "d14766da37af90e60fb96aa3cbdc058f.c", "FileName": "libavfilter/framesync.c", "Line": 255, "Tip": "Program reaches the return point, modifying the value <b>*(rframe)</b> to null", "SrcLines": ["    fs->in[in].have_next  = 1;", "}", "", "int ff_framesync_get_frame(FFFrameSync *fs, unsigned in, AVFrame **rframe,", "                            unsigned get)", "{", "    AVFrame *frame;", "    unsigned need_copy = 0, i;", "    int64_t pts_next;", "    int ret;"], "SrcStart": 250}, {"FileMD5": "b646a1f4c89ef119b71d9495c51d9126.c", "FileName": "libavfilter/vf_midequalizer.c", "Line": 98, "Tip": "Function <b>ff_framesync_get_frame</b> modifies the value <b>in1</b> to null, where <b>&amp;(in1)</b> is used as the 3rd parameter (<b>rframe</b>)", "SrcLines": ["    AVFilterLink *outlink = ctx->outputs[0];", "    AVFrame *out, *in0, *in1;", "    int ret;", "", "    if ((ret = ff_framesync_get_frame(&s->fs, 0, &in0, 0)) < 0 ||", "        (ret = ff_framesync_get_frame(&s->fs, 1, &in1, 0)) < 0)", "        return ret;", "", "    if (ctx->is_disabled) {", "        out = av_frame_clone(in0);"], "SrcStart": 93}, {"FileMD5": "b646a1f4c89ef119b71d9495c51d9126.c", "FileName": "libavfilter/vf_midequalizer.c", "Line": 120, "Tip": "Load value from <b>in1</b>", "SrcLines": ["                av_image_copy_plane(out->data[p], out->linesize[p], in0->data[p], in0->linesize[p],", "                                    s->width[0][p] * (1 + (s->histogram_size > 256)), s->height[0][p]);", "                continue;", "            }", "", "            s->midequalizer(in0->data[p], in1->data[p],", "                            out->data[p],", "                            in0->linesize[p], in1->linesize[p],", "                            out->linesize[p],", "                            s->width[0][p], s->height[0][p],"], "SrcStart": 115}, {"FileMD5": "b646a1f4c89ef119b71d9495c51d9126.c", "FileName": "libavfilter/vf_midequalizer.c", "Line": 120, "Tip": "Load value from <b>in1-&gt;data[i]</b>", "SrcLines": ["                av_image_copy_plane(out->data[p], out->linesize[p], in0->data[p], in0->linesize[p],", "                                    s->width[0][p] * (1 + (s->histogram_size > 256)), s->height[0][p]);", "                continue;", "            }", "", "            s->midequalizer(in0->data[p], in1->data[p],", "                            out->data[p],", "                            in0->linesize[p], in1->linesize[p],", "                            out->linesize[p],", "                            s->width[0][p], s->height[0][p],"], "SrcStart": 115}], "Review": 80, "Time": 1629219860000, "DocID": "PE0001", "File": "libavfilter/vf_midequalizer.c", "Line": 120}, {"HashID": "e5d1a3ad21e4578c0450afd8c5872726", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "d14766da37af90e60fb96aa3cbdc058f.c", "FileName": "libavfilter/framesync.c", "Line": 262, "Tip": "Store <b>null</b> to <b>rframe</b>", "SrcLines": ["    unsigned need_copy = 0, i;", "    int64_t pts_next;", "    int ret;", "", "    if (!fs->in[in].frame) {", "        *rframe = NULL;", "        return 0;", "    }", "    frame = fs->in[in].frame;", "    if (get) {"], "SrcStart": 257}, {"FileMD5": "d14766da37af90e60fb96aa3cbdc058f.c", "FileName": "libavfilter/framesync.c", "Line": 255, "Tip": "Program reaches the return point, modifying the value <b>*(rframe)</b> to null", "SrcLines": ["    fs->in[in].have_next  = 1;", "}", "", "int ff_framesync_get_frame(FFFrameSync *fs, unsigned in, AVFrame **rframe,", "                            unsigned get)", "{", "    AVFrame *frame;", "    unsigned need_copy = 0, i;", "    int64_t pts_next;", "    int ret;"], "SrcStart": 250}, {"FileMD5": "b646a1f4c89ef119b71d9495c51d9126.c", "FileName": "libavfilter/vf_midequalizer.c", "Line": 97, "Tip": "Function <b>ff_framesync_get_frame</b> modifies the value <b>in0</b> to null, where <b>&amp;(in0)</b> is used as the 3rd parameter (<b>rframe</b>)", "SrcLines": ["    MidEqualizerContext *s = fs->opaque;", "    AVFilterLink *outlink = ctx->outputs[0];", "    AVFrame *out, *in0, *in1;", "    int ret;", "", "    if ((ret = ff_framesync_get_frame(&s->fs, 0, &in0, 0)) < 0 ||", "        (ret = ff_framesync_get_frame(&s->fs, 1, &in1, 0)) < 0)", "        return ret;", "", "    if (ctx->is_disabled) {"], "SrcStart": 92}, {"FileMD5": "b646a1f4c89ef119b71d9495c51d9126.c", "FileName": "libavfilter/vf_midequalizer.c", "Line": 122, "Tip": "Load value from <b>in0</b>", "SrcLines": ["                continue;", "            }", "", "            s->midequalizer(in0->data[p], in1->data[p],", "                            out->data[p],", "                            in0->linesize[p], in1->linesize[p],", "                            out->linesize[p],", "                            s->width[0][p], s->height[0][p],", "                            s->width[1][p], s->height[1][p],", "                            s->histogram[0], s->histogram[1],"], "SrcStart": 117}, {"FileMD5": "b646a1f4c89ef119b71d9495c51d9126.c", "FileName": "libavfilter/vf_midequalizer.c", "Line": 122, "Tip": "Load value from <b>in0-&gt;linesize[i]</b>", "SrcLines": ["                continue;", "            }", "", "            s->midequalizer(in0->data[p], in1->data[p],", "                            out->data[p],", "                            in0->linesize[p], in1->linesize[p],", "                            out->linesize[p],", "                            s->width[0][p], s->height[0][p],", "                            s->width[1][p], s->height[1][p],", "                            s->histogram[0], s->histogram[1],"], "SrcStart": 117}], "Review": 80, "Time": 1629219860000, "DocID": "PE0001", "File": "libavfilter/vf_midequalizer.c", "Line": 122}, {"HashID": "d53919ebb7d433772dc5eb5836969221", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "5dc66c0497473dfb36694a5715c2f472.c", "FileName": "libavfilter/vf_tpad.c", "Line": 77, "Tip": "Store <b>null</b> to <b>frame</b>", "SrcLines": ["static int activate(AVFilterContext *ctx)", "{", "    AVFilterLink *inlink = ctx->inputs[0];", "    AVFilterLink *outlink = ctx->outputs[0];", "    TPadContext *s = ctx->priv;", "    AVFrame *frame = NULL;", "    int ret, status;", "    int64_t pts;", "", "    FF_FILTER_FORWARD_STATUS_BACK(outlink, inlink);"], "SrcStart": 72}, {"FileMD5": "5dc66c0497473dfb36694a5715c2f472.c", "FileName": "libavfilter/vf_tpad.c", "Line": 155, "Tip": "Load value from <b>frame</b>", "SrcLines": ["        } else if (s->stop_mode == 1) {", "            frame = av_frame_clone(s->cache_stop);", "            if (!frame)", "                return AVERROR(ENOMEM);", "        }", "        frame->pts = s->pts;", "        s->pts += av_rescale_q(1, av_inv_q(outlink->frame_rate), outlink->time_base);", "        if (s->pad_stop > 0)", "            s->pad_stop--;", "        return ff_filter_frame(outlink, frame);"], "SrcStart": 150}, {"FileMD5": "5dc66c0497473dfb36694a5715c2f472.c", "FileName": "libavfilter/vf_tpad.c", "Line": 155, "Tip": "Store <b>s-&gt;pts13</b> to <b>frame-&gt;pts</b>", "SrcLines": ["        } else if (s->stop_mode == 1) {", "            frame = av_frame_clone(s->cache_stop);", "            if (!frame)", "                return AVERROR(ENOMEM);", "        }", "        frame->pts = s->pts;", "        s->pts += av_rescale_q(1, av_inv_q(outlink->frame_rate), outlink->time_base);", "        if (s->pad_stop > 0)", "            s->pad_stop--;", "        return ff_filter_frame(outlink, frame);"], "SrcStart": 150}], "Review": 80, "Time": 1629219860000, "DocID": "PE0001", "File": "libavfilter/vf_tpad.c", "Line": 155}, {"HashID": "c4ecadd1493d77f64d8c29f9cf350853", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "cbc23179f1e3aefe81c3ef5760b4e986.c", "FileName": "libavformat/oggenc.c", "Line": 607, "Tip": "Select the false branch at this point (<b>i&lt;s-&gt;nb_streams</b> is false)", "SrcLines": ["static int ogg_write_header(AVFormatContext *s)", "{", "    OGGStreamContext *oggstream = NULL;", "    int i, j;", "", "    for (j = 0; j < s->nb_streams; j++) {", "        oggstream = s->streams[j]->priv_data;", "        ogg_buffer_data(s, s->streams[j], oggstream->header[0],", "                        oggstream->header_len[0], 0, 1);", "        oggstream->page.flags |= 2; // bos"], "SrcStart": 602}, {"FileMD5": "cbc23179f1e3aefe81c3ef5760b4e986.c", "FileName": "libavformat/oggenc.c", "Line": 614, "Tip": "Select the false branch at this point (<b>i&lt;s-&gt;nb_streams</b> is false)", "SrcLines": ["        ogg_buffer_data(s, s->streams[j], oggstream->header[0],", "                        oggstream->header_len[0], 0, 1);", "        oggstream->page.flags |= 2; // bos", "        ogg_buffer_page(s, oggstream);", "    }", "    for (j = 0; j < s->nb_streams; j++) {", "        AVStream *st = s->streams[j];", "        oggstream = st->priv_data;", "        for (i = 1; i < 3; i++) {", "            if (oggstream->header_len[i])"], "SrcStart": 609}, {"FileMD5": "cbc23179f1e3aefe81c3ef5760b4e986.c", "FileName": "libavformat/oggenc.c", "Line": 625, "Tip": "Store <b>-9223372036854775808</b> to <b>oggstream-&gt;page.start_granule</b>", "SrcLines": ["                                oggstream->header_len[i], 0, 1);", "        }", "        ogg_buffer_page(s, oggstream);", "    }", "", "    oggstream->page.start_granule = AV_NOPTS_VALUE;", "", "    ogg_write_pages(s, 2);", "", "    return 0;"], "SrcStart": 620}], "Review": 80, "Time": 1629219860000, "DocID": "PE0001", "File": "libavformat/oggenc.c", "Line": 625}, {"HashID": "1fbcbdbfb61ede4bee693b60c687c68b", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "08bb623847c7b3265ee1b37202477b3f.c", "FileName": "fftools/ffplay.c", "Line": 2253, "Tip": "<b>null</b> is used as the 2nd parameter in function <b>decoder_decode_frame</b>", "SrcLines": ["", "    for (;;) {", "        if (!(sp = frame_queue_peek_writable(&is->subpq)))", "            return 0;", "", "        if ((got_subtitle = decoder_decode_frame(&is->subdec, NULL, &sp->sub)) < 0)", "            break;", "", "        pts = 0;", ""], "SrcStart": 2248}, {"FileMD5": "08bb623847c7b3265ee1b37202477b3f.c", "FileName": "fftools/ffplay.c", "Line": 607, "Tip": "Load value from <b>frame-&gt;best_effort_timestamp</b>", "SrcLines": ["                switch (d->avctx->codec_type) {", "                    case AVMEDIA_TYPE_VIDEO:", "                        ret = avcodec_receive_frame(d->avctx, frame);", "                        if (ret >= 0) {", "                            if (decoder_reorder_pts == -1) {", "                                frame->pts = frame->best_effort_timestamp;", "                            } else if (!decoder_reorder_pts) {", "                                frame->pts = frame->pkt_dts;", "                            }", "                        }"], "SrcStart": 602}], "Review": 80, "Time": 1629218470000, "DocID": "PE0001", "File": "fftools/ffplay.c", "Line": 607}, {"HashID": "e4bbb4f008990bf68cbbcd93b683d2fc", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "08bb623847c7b3265ee1b37202477b3f.c", "FileName": "fftools/ffplay.c", "Line": 2253, "Tip": "<b>null</b> is used as the 2nd parameter in function <b>decoder_decode_frame</b>", "SrcLines": ["", "    for (;;) {", "        if (!(sp = frame_queue_peek_writable(&is->subpq)))", "            return 0;", "", "        if ((got_subtitle = decoder_decode_frame(&is->subdec, NULL, &sp->sub)) < 0)", "            break;", "", "        pts = 0;", ""], "SrcStart": 2248}, {"FileMD5": "08bb623847c7b3265ee1b37202477b3f.c", "FileName": "fftools/ffplay.c", "Line": 616, "Tip": "Load value from <b>frame-&gt;sample_rate</b>", "SrcLines": ["                        }", "                        break;", "                    case AVMEDIA_TYPE_AUDIO:", "                        ret = avcodec_receive_frame(d->avctx, frame);", "                        if (ret >= 0) {", "                            AVRational tb = (AVRational){1, frame->sample_rate};", "                            if (frame->pts != AV_NOPTS_VALUE)", "                                frame->pts = av_rescale_q(frame->pts, d->avctx->pkt_timebase, tb);", "                            else if (d->next_pts != AV_NOPTS_VALUE)", "                                frame->pts = av_rescale_q(d->next_pts, d->next_pts_tb, tb);"], "SrcStart": 611}], "Review": 80, "Time": 1629218470000, "DocID": "PE0001", "File": "fftools/ffplay.c", "Line": 616}, {"HashID": "24e9f0c529d16037f4075e8f41de13ed", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "691dd5f7fb64670d0ef49c8127af5a86.c", "FileName": "libavcodec/ac3enc.c", "Line": 279, "Tip": "Select the false branch at this point (<b>s-&gt;rematrixing_enabled==0</b> is false)", "SrcLines": ["    int nb_coefs;", "    int blk, bnd, i;", "    int start, end;", "    uint8_t *flags = NULL;", "", "    if (!s->rematrixing_enabled)", "        return;", "", "    for (blk = 0; blk < s->num_blocks; blk++) {", "        AC3Block *block = &s->blocks[blk];"], "SrcStart": 274}, {"FileMD5": "691dd5f7fb64670d0ef49c8127af5a86.c", "FileName": "libavcodec/ac3enc.c", "Line": 284, "Tip": "Select the false branch at this point (<b>s-&gt;blocks[i].new_rematrixing_strategy!=0</b> is false)", "SrcLines": ["    if (!s->rematrixing_enabled)", "        return;", "", "    for (blk = 0; blk < s->num_blocks; blk++) {", "        AC3Block *block = &s->blocks[blk];", "        if (block->new_rematrixing_strategy)", "            flags = block->rematrixing_flags;", "        nb_coefs = FFMIN(block->end_freq[1], block->end_freq[2]);", "        for (bnd = 0; bnd < block->num_rematrixing_bands; bnd++) {", "            if (flags[bnd]) {"], "SrcStart": 279}, {"FileMD5": "691dd5f7fb64670d0ef49c8127af5a86.c", "FileName": "libavcodec/ac3enc.c", "Line": 287, "Tip": "Select the false branch at this point (<b>i&lt;s-&gt;blocks[i].num_rematrixing_bands</b> is false)", "SrcLines": ["    for (blk = 0; blk < s->num_blocks; blk++) {", "        AC3Block *block = &s->blocks[blk];", "        if (block->new_rematrixing_strategy)", "            flags = block->rematrixing_flags;", "        nb_coefs = FFMIN(block->end_freq[1], block->end_freq[2]);", "        for (bnd = 0; bnd < block->num_rematrixing_bands; bnd++) {", "            if (flags[bnd]) {", "                start = ff_ac3_rematrix_band_tab[bnd];", "                end   = FFMIN(nb_coefs, ff_ac3_rematrix_band_tab[bnd+1]);", "                for (i = start; i < end; i++) {"], "SrcStart": 282}, {"FileMD5": "691dd5f7fb64670d0ef49c8127af5a86.c", "FileName": "libavcodec/ac3enc.c", "Line": 284, "Tip": "Select the false branch at this point (<b>s-&gt;blocks[i].new_rematrixing_strategy!=0</b> is false)", "SrcLines": ["    if (!s->rematrixing_enabled)", "        return;", "", "    for (blk = 0; blk < s->num_blocks; blk++) {", "        AC3Block *block = &s->blocks[blk];", "        if (block->new_rematrixing_strategy)", "            flags = block->rematrixing_flags;", "        nb_coefs = FFMIN(block->end_freq[1], block->end_freq[2]);", "        for (bnd = 0; bnd < block->num_rematrixing_bands; bnd++) {", "            if (flags[bnd]) {"], "SrcStart": 279}, {"FileMD5": "691dd5f7fb64670d0ef49c8127af5a86.c", "FileName": "libavcodec/ac3enc.c", "Line": 288, "Tip": "Load value from <b>flags[i]</b>", "SrcLines": ["        AC3Block *block = &s->blocks[blk];", "        if (block->new_rematrixing_strategy)", "            flags = block->rematrixing_flags;", "        nb_coefs = FFMIN(block->end_freq[1], block->end_freq[2]);", "        for (bnd = 0; bnd < block->num_rematrixing_bands; bnd++) {", "            if (flags[bnd]) {", "                start = ff_ac3_rematrix_band_tab[bnd];", "                end   = FFMIN(nb_coefs, ff_ac3_rematrix_band_tab[bnd+1]);", "                for (i = start; i < end; i++) {", "                    int32_t lt = block->fixed_coef[1][i];"], "SrcStart": 283}], "Review": 80, "Time": 1629218470000, "DocID": "PE0001", "File": "libavcodec/ac3enc.c", "Line": 288}, {"HashID": "a604c7e7d5ea6ee65a9ec96a4ccddbef", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "ff664eb4f297e90ee2c59faab7d4dba3.c", "FileName": "libavcodec/ccaption_dec.c", "Line": 398, "Tip": "Return <b>null</b> to caller", "SrcLines": ["        // use active screen", "        return ctx->screen + ctx->active_screen;", "    }", "    /* It was never an option */", "    return NULL;", "}", "", "static void roll_up(CCaptionSubContext *ctx)", "{", "    struct Screen *screen;"], "SrcStart": 393}, {"FileMD5": "ff664eb4f297e90ee2c59faab7d4dba3.c", "FileName": "libavcodec/ccaption_dec.c", "Line": 558, "Tip": "Function <b>get_writing_screen</b> executes and stores the return value to <b>screen</b> (<b>screen</b> can be null)", "SrcLines": ["{", "    static const int8_t row_map[] = {", "        11, -1, 1, 2, 3, 4, 12, 13, 14, 15, 5, 6, 7, 8, 9, 10", "    };", "    const int index = ( (hi<<1) & 0x0e) | ( (lo>>5) & 0x01 );", "    struct Screen *screen = get_writing_screen(ctx);", "    int indent, i;", "", "    if (row_map[index] <= 0) {", "        av_log(ctx, AV_LOG_DEBUG, \"Invalid pac index encountered\\n\");"], "SrcStart": 553}, {"FileMD5": "ff664eb4f297e90ee2c59faab7d4dba3.c", "FileName": "libavcodec/ccaption_dec.c", "Line": 575, "Tip": "<b>screen</b> is used as the 2nd parameter in function <b>write_char</b> (<b>screen</b> can be null)", "SrcLines": ["    ctx->cursor_font = pac2_attribs[lo][1];", "    ctx->cursor_charset = CCSET_BASIC_AMERICAN;", "    ctx->cursor_column = 0;", "    indent = pac2_attribs[lo][2];", "    for (i = 0; i < indent; i++) {", "        write_char(ctx, screen, ' ');", "    }", "}", "", "/**"], "SrcStart": 570}, {"FileMD5": "ff664eb4f297e90ee2c59faab7d4dba3.c", "FileName": "libavcodec/ccaption_dec.c", "Line": 326, "Tip": "Store <b>ctx-&gt;cursor_font</b> to <b>screen-&gt;fonts[ctx-&gt;cursor_row][0][col]</b>", "SrcLines": ["    char *font = screen->fonts[ctx->cursor_row];", "    char *charset = screen->charsets[ctx->cursor_row];", "", "    if (col < SCREEN_COLUMNS) {", "        row[col] = ch;", "        font[col] = ctx->cursor_font;", "        charset[col] = ctx->cursor_charset;", "        ctx->cursor_charset = CCSET_BASIC_AMERICAN;", "        if (ch) ctx->cursor_column++;", "        return;"], "SrcStart": 321}], "Review": 80, "Time": 1629218470000, "DocID": "PE0001", "File": "libavcodec/ccaption_dec.c", "Line": 326}, {"HashID": "4c79f30250fd1a9209bd984af7b0624b", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "ff664eb4f297e90ee2c59faab7d4dba3.c", "FileName": "libavcodec/ccaption_dec.c", "Line": 398, "Tip": "Return <b>null</b> to caller", "SrcLines": ["        // use active screen", "        return ctx->screen + ctx->active_screen;", "    }", "    /* It was never an option */", "    return NULL;", "}", "", "static void roll_up(CCaptionSubContext *ctx)", "{", "    struct Screen *screen;"], "SrcStart": 393}, {"FileMD5": "ff664eb4f297e90ee2c59faab7d4dba3.c", "FileName": "libavcodec/ccaption_dec.c", "Line": 540, "Tip": "Function <b>get_writing_screen</b> executes and stores the return value to <b>screen</b> (<b>screen</b> can be null)", "SrcLines": ["}", "", "static void handle_textattr(CCaptionSubContext *ctx, uint8_t hi, uint8_t lo)", "{", "    int i = lo - 0x20;", "    struct Screen *screen = get_writing_screen(ctx);", "", "    if (i >= 32)", "        return;", ""], "SrcStart": 535}, {"FileMD5": "ff664eb4f297e90ee2c59faab7d4dba3.c", "FileName": "libavcodec/ccaption_dec.c", "Line": 549, "Tip": "<b>screen</b> is used as the 2nd parameter in function <b>write_char</b> (<b>screen</b> can be null)", "SrcLines": ["", "    ctx->cursor_color = pac2_attribs[i][0];", "    ctx->cursor_font = pac2_attribs[i][1];", "", "    SET_FLAG(screen->row_used, ctx->cursor_row);", "    write_char(ctx, screen, ' ');", "}", "", "static void handle_pac(CCaptionSubContext *ctx, uint8_t hi, uint8_t lo)", "{"], "SrcStart": 544}, {"FileMD5": "ff664eb4f297e90ee2c59faab7d4dba3.c", "FileName": "libavcodec/ccaption_dec.c", "Line": 327, "Tip": "Store <b>ctx-&gt;cursor_charset</b> to <b>screen-&gt;charsets[ctx-&gt;cursor_row][0][col]</b>", "SrcLines": ["    char *charset = screen->charsets[ctx->cursor_row];", "", "    if (col < SCREEN_COLUMNS) {", "        row[col] = ch;", "        font[col] = ctx->cursor_font;", "        charset[col] = ctx->cursor_charset;", "        ctx->cursor_charset = CCSET_BASIC_AMERICAN;", "        if (ch) ctx->cursor_column++;", "        return;", "    }"], "SrcStart": 322}], "Review": 80, "Time": 1629218470000, "DocID": "PE0001", "File": "libavcodec/ccaption_dec.c", "Line": 327}, {"HashID": "883b5ab1a850506cf64c843dd94f9a2f", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "ff664eb4f297e90ee2c59faab7d4dba3.c", "FileName": "libavcodec/ccaption_dec.c", "Line": 398, "Tip": "Return <b>null</b> to caller", "SrcLines": ["        // use active screen", "        return ctx->screen + ctx->active_screen;", "    }", "    /* It was never an option */", "    return NULL;", "}", "", "static void roll_up(CCaptionSubContext *ctx)", "{", "    struct Screen *screen;"], "SrcStart": 393}, {"FileMD5": "ff664eb4f297e90ee2c59faab7d4dba3.c", "FileName": "libavcodec/ccaption_dec.c", "Line": 617, "Tip": "Function <b>get_writing_screen</b> executes and stores the return value to <b>screen</b> (<b>screen</b> can be null)", "SrcLines": ["        reap_screen(ctx, pts);", "}", "", "static void handle_delete_end_of_row(CCaptionSubContext *ctx, char hi, char lo)", "{", "    struct Screen *screen = get_writing_screen(ctx);", "    write_char(ctx, screen, 0);", "}", "", "static void handle_char(CCaptionSubContext *ctx, char hi, char lo, int64_t pts)"], "SrcStart": 612}, {"FileMD5": "ff664eb4f297e90ee2c59faab7d4dba3.c", "FileName": "libavcodec/ccaption_dec.c", "Line": 618, "Tip": "<b>screen</b> is used as the 2nd parameter in function <b>write_char</b> (<b>screen</b> can be null)", "SrcLines": ["}", "", "static void handle_delete_end_of_row(CCaptionSubContext *ctx, char hi, char lo)", "{", "    struct Screen *screen = get_writing_screen(ctx);", "    write_char(ctx, screen, 0);", "}", "", "static void handle_char(CCaptionSubContext *ctx, char hi, char lo, int64_t pts)", "{"], "SrcStart": 613}, {"FileMD5": "ff664eb4f297e90ee2c59faab7d4dba3.c", "FileName": "libavcodec/ccaption_dec.c", "Line": 334, "Tip": "Store <b>ch</b> to <b>screen-&gt;characters[ctx-&gt;cursor_row][0][col]</b>", "SrcLines": ["        if (ch) ctx->cursor_column++;", "        return;", "    }", "    /* We have extra space at end only for null character */", "    else if (col == SCREEN_COLUMNS && ch == 0) {", "        row[col] = ch;", "        return;", "    }", "    else {", "        av_log(ctx, AV_LOG_WARNING, \"Data Ignored since exceeding screen width\\n\");"], "SrcStart": 329}], "Review": 80, "Time": 1629218470000, "DocID": "PE0001", "File": "libavcodec/ccaption_dec.c", "Line": 334}]}, "start": 11, "end": 20, "page": 3, "total_pages": 9, "language": "en"}