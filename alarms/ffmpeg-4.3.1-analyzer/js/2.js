var data = {"bug_cases": {"BugType": "NULL pointer dereference", "Severity": 12, "DocHTML": "<div class=\"toc\">\n<ul>\n<li><a href=\"#description\">Description</a></li>\n<li><a href=\"#vulnerability-and-risk\">Vulnerability and Risk</a><ul>\n<li><a href=\"#dos-crash-exit-restart\">DoS / crash / exit / restart</a></li>\n<li><a href=\"#execute-unauthorized-code-or-commands\">Execute unauthorized code or commands</a></li>\n</ul>\n</li>\n<li><a href=\"#likelihood-of-exploit\">Likelihood of Exploit</a></li>\n<li><a href=\"#potential-mitigations\">Potential Mitigations</a></li>\n<li><a href=\"#demonstrative-examples\">Demonstrative Examples</a><ul>\n<li><a href=\"#vulnerable-code-example-1\">Vulnerable code Example 1</a></li>\n<li><a href=\"#fixed-code-example-1\">Fixed Code Example 1</a></li>\n<li><a href=\"#vulnerable-code-example-2\">Vulnerable code Example 2</a></li>\n<li><a href=\"#fixed-code-example-2\">Fixed code example 2</a></li>\n<li><a href=\"#vulnerable-code-example-3\">Vulnerable code Example 3</a></li>\n<li><a href=\"#fixed-code-example-3\">Fixed code example 3</a></li>\n</ul>\n</li>\n<li><a href=\"#references\">References</a></li>\n</ul>\n</div>\n\n  <div>\n    \n<h1 id=\"description\">Description</h1>\n<p>An attempt to access data using a null pointer causes a runtime error. When a program dereferences a pointer that is expected to be valid but turns out to be null, a null pointer dereference occurs. Null-pointer dereference defects often occur due to ineffective error handling or race conditions, and typically cause abnormal program termination. Before a pointer is dereferenced in C/C++ code, it must be checked to confirm that it is not equal to null.</p>\n<h1 id=\"vulnerability-and-risk\">Vulnerability and Risk</h1>\n<h4 id=\"dos-crash-exit-restart\">DoS / crash / exit / restart</h4>\n<p>NULL pointer dereferences usually result in the failure of the process unless exception handling (on some platforms) is available and implemented. Even when exception handling is being used, it can still be very difficult to return the software to a safe state of operation.</p>\n<h4 id=\"execute-unauthorized-code-or-commands\">Execute unauthorized code or commands</h4>\n<p>In very rare circumstances and environments, code execution is possible.</p>\n<h1 id=\"likelihood-of-exploit\">Likelihood of Exploit</h1>\n<p>Critical</p>\n<h1 id=\"potential-mitigations\">Potential Mitigations</h1>\n<ul>\n<li>Check for a null value in the results of all functions that return values</li>\n<li>Make sure all external inputs are validated</li>\n<li>Explicitly initialize variables</li>\n<li>Make sure that unusual exceptions are handled correctly</li>\n</ul>\n<h1 id=\"demonstrative-examples\">Demonstrative Examples</h1>\n<h3 id=\"vulnerable-code-example-1\">Vulnerable code Example 1</h3>\n<table class=\"highlighttable\"><tr><td class=\"linenos\"><div class=\"linenodiv\"><pre> 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12</pre></div></td><td class=\"code\"><div class=\"highlight\"><pre><span></span><span class=\"kt\">void</span> <span class=\"nf\">reassign</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"o\">*</span><span class=\"n\">argument</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"o\">*</span><span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">goodEnough</span><span class=\"p\">(</span><span class=\"n\">argument</span><span class=\"p\">))</span> <span class=\"k\">return</span><span class=\"p\">;</span>\n  <span class=\"o\">*</span><span class=\"n\">argument</span> <span class=\"o\">=</span> <span class=\"o\">*</span><span class=\"n\">p</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">npd_check_call_must</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"o\">*</span><span class=\"n\">argument</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"kt\">int</span> <span class=\"o\">*</span><span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">getValue</span><span class=\"p\">();</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">p</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"o\">*</span><span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n  <span class=\"n\">reassign</span><span class=\"p\">(</span><span class=\"n\">argument</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</pre></div>\n</td></tr></table>\n<p>Although *p is checked for null at line 8, it's then passed to function reassign, in which it is dereferenced without being checked for null. This type of vulnerability can produce unexpected and unintended results.</p>\n<h3 id=\"fixed-code-example-1\">Fixed Code Example 1</h3>\n<table class=\"highlighttable\"><tr><td class=\"linenos\"><div class=\"linenodiv\"><pre> 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12</pre></div></td><td class=\"code\"><div class=\"highlight\"><pre><span></span><span class=\"kt\">void</span> <span class=\"nf\">reassign</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"o\">*</span><span class=\"n\">argument</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"o\">*</span><span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">goodEnough</span><span class=\"p\">(</span><span class=\"n\">argument</span><span class=\"p\">))</span> <span class=\"k\">return</span><span class=\"p\">;</span>\n  <span class=\"o\">*</span><span class=\"n\">argument</span> <span class=\"o\">=</span> <span class=\"o\">*</span><span class=\"n\">p</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">npd_check_call_must</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"o\">*</span><span class=\"n\">argument</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"kt\">int</span> <span class=\"o\">*</span><span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">getValue</span><span class=\"p\">();</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">p</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"o\">*</span><span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">p</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"n\">reassign</span><span class=\"p\">(</span><span class=\"n\">argument</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</pre></div>\n</td></tr></table>\n<p>In the fixed version of the code, a second check for null has been put in line 11.</p>\n<h3 id=\"vulnerable-code-example-2\">Vulnerable code Example 2</h3>\n<p>This example takes an IP address from a user, verifies that it is well formed and then looks up the hostname and copies it into a buffer.</p>\n<table class=\"highlighttable\"><tr><td class=\"linenos\"><div class=\"linenodiv\"><pre> 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12</pre></div></td><td class=\"code\"><div class=\"highlight\"><pre><span></span><span class=\"kt\">void</span> <span class=\"nf\">host_lookup</span><span class=\"p\">(</span><span class=\"kt\">char</span> <span class=\"o\">*</span><span class=\"n\">user_supplied_addr</span><span class=\"p\">){</span>\n  <span class=\"k\">struct</span> <span class=\"n\">hostent</span> <span class=\"o\">*</span><span class=\"n\">hp</span><span class=\"p\">;</span>\n  <span class=\"n\">in_addr_t</span> <span class=\"o\">*</span><span class=\"n\">addr</span><span class=\"p\">;</span>\n  <span class=\"kt\">char</span> <span class=\"n\">hostname</span><span class=\"p\">[</span><span class=\"mi\">64</span><span class=\"p\">];</span>\n  <span class=\"n\">in_addr_t</span> <span class=\"n\">inet_addr</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"kt\">char</span> <span class=\"o\">*</span><span class=\"n\">cp</span><span class=\"p\">);</span>\n\n  <span class=\"c1\">// routine that ensures user_supplied_addr is in the right format for conversion </span>\n  <span class=\"n\">validate_addr_form</span><span class=\"p\">(</span><span class=\"n\">user_supplied_addr</span><span class=\"p\">);</span>\n  <span class=\"n\">addr</span> <span class=\"o\">=</span> <span class=\"n\">inet_addr</span><span class=\"p\">(</span><span class=\"n\">user_supplied_addr</span><span class=\"p\">);</span>\n  <span class=\"n\">hp</span> <span class=\"o\">=</span> <span class=\"n\">gethostbyaddr</span><span class=\"p\">(</span> <span class=\"n\">addr</span><span class=\"p\">,</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"k\">struct</span> <span class=\"n\">in_addr</span><span class=\"p\">),</span> <span class=\"n\">AF_INET</span><span class=\"p\">);</span>\n  <span class=\"n\">strcpy</span><span class=\"p\">(</span><span class=\"n\">hostname</span><span class=\"p\">,</span> <span class=\"n\">hp</span><span class=\"o\">-&gt;</span><span class=\"n\">h_name</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</pre></div>\n</td></tr></table>\n<p>If an attacker provides an address that appears to be well-formed, but the address does not resolve to a hostname, then the call to gethostbyaddr() will return NULL. Since the code does not check the return value from gethostbyaddr, a NULL pointer dereference would then occur in the call to strcpy().</p>\n<h3 id=\"fixed-code-example-2\">Fixed code example 2</h3>\n<table class=\"highlighttable\"><tr><td class=\"linenos\"><div class=\"linenodiv\"><pre> 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12</pre></div></td><td class=\"code\"><div class=\"highlight\"><pre><span></span><span class=\"kt\">void</span> <span class=\"nf\">host_lookup</span><span class=\"p\">(</span><span class=\"kt\">char</span> <span class=\"o\">*</span><span class=\"n\">user_supplied_addr</span><span class=\"p\">){</span>\n  <span class=\"k\">struct</span> <span class=\"n\">hostent</span> <span class=\"o\">*</span><span class=\"n\">hp</span><span class=\"p\">;</span>\n  <span class=\"n\">in_addr_t</span> <span class=\"o\">*</span><span class=\"n\">addr</span><span class=\"p\">;</span>\n  <span class=\"kt\">char</span> <span class=\"n\">hostname</span><span class=\"p\">[</span><span class=\"mi\">64</span><span class=\"p\">];</span>\n  <span class=\"n\">in_addr_t</span> <span class=\"n\">inet_addr</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"kt\">char</span> <span class=\"o\">*</span><span class=\"n\">cp</span><span class=\"p\">);</span>\n\n  <span class=\"c1\">// routine that ensures user_supplied_addr is in the right format for conversion </span>\n  <span class=\"n\">validate_addr_form</span><span class=\"p\">(</span><span class=\"n\">user_supplied_addr</span><span class=\"p\">);</span>\n  <span class=\"n\">addr</span> <span class=\"o\">=</span> <span class=\"n\">inet_addr</span><span class=\"p\">(</span><span class=\"n\">user_supplied_addr</span><span class=\"p\">);</span>\n  <span class=\"n\">hp</span> <span class=\"o\">=</span> <span class=\"n\">gethostbyaddr</span><span class=\"p\">(</span> <span class=\"n\">addr</span><span class=\"p\">,</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"k\">struct</span> <span class=\"n\">in_addr</span><span class=\"p\">),</span> <span class=\"n\">AF_INET</span><span class=\"p\">);</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">hp</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"n\">strcpy</span><span class=\"p\">(</span><span class=\"n\">hostname</span><span class=\"p\">,</span> <span class=\"n\">hp</span><span class=\"o\">-&gt;</span><span class=\"n\">h_name</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</pre></div>\n</td></tr></table>\n<p>In the fixed version of the code, another null check was added on line 11.</p>\n<h3 id=\"vulnerable-code-example-3\">Vulnerable code Example 3</h3>\n<p>This java example illustrates missing check of returned value might lead to crash of a program.</p>\n<table class=\"highlighttable\"><tr><td class=\"linenos\"><div class=\"linenodiv\"><pre> 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23</pre></div></td><td class=\"code\"><div class=\"highlight\"><pre><span></span><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Example</span> <span class=\"o\">{</span>\n  <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"n\">String</span> <span class=\"nf\">readConfigFromFile</span><span class=\"o\">(</span><span class=\"n\">File</span> <span class=\"n\">file</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">try</span> <span class=\"o\">(</span><span class=\"n\">FileReader</span> <span class=\"n\">reader</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">FileReader</span><span class=\"o\">(</span><span class=\"n\">file</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n      <span class=\"kt\">char</span><span class=\"o\">[]</span> <span class=\"n\">buffer</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">char</span><span class=\"o\">[(</span><span class=\"kt\">int</span><span class=\"o\">)</span> <span class=\"n\">file</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()];</span>\n      <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">reader</span><span class=\"o\">.</span><span class=\"na\">read</span><span class=\"o\">(</span><span class=\"n\">buffer</span><span class=\"o\">)</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n      <span class=\"o\">}</span>\n      <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">String</span><span class=\"o\">(</span><span class=\"n\">buffer</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">io</span><span class=\"o\">.</span><span class=\"na\">IOException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n      <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n  <span class=\"o\">}</span>\n\n  <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">args</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n      <span class=\"k\">return</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"n\">String</span> <span class=\"n\">config</span> <span class=\"o\">=</span> <span class=\"n\">readConfigFromFile</span><span class=\"o\">(</span><span class=\"n\">args</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]);</span>\n    <span class=\"c1\">// config might be null. If so, main exits.</span>\n    <span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">lines</span> <span class=\"o\">=</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"na\">split</span><span class=\"o\">(</span><span class=\"s\">\"\\n\"</span><span class=\"o\">);</span>\n    <span class=\"o\">...</span>\n  <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre></div>\n</td></tr></table>\n<h3 id=\"fixed-code-example-3\">Fixed code example 3</h3>\n<table class=\"highlighttable\"><tr><td class=\"linenos\"><div class=\"linenodiv\"><pre> 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26</pre></div></td><td class=\"code\"><div class=\"highlight\"><pre><span></span><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Example</span> <span class=\"o\">{</span>\n  <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"n\">String</span> <span class=\"nf\">readConfigFromFile</span><span class=\"o\">(</span><span class=\"n\">File</span> <span class=\"n\">file</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">try</span> <span class=\"o\">(</span><span class=\"n\">FileReader</span> <span class=\"n\">reader</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">FileReader</span><span class=\"o\">(</span><span class=\"n\">file</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n      <span class=\"kt\">char</span><span class=\"o\">[]</span> <span class=\"n\">buffer</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">char</span><span class=\"o\">[(</span><span class=\"kt\">int</span><span class=\"o\">)</span> <span class=\"n\">file</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()];</span>\n      <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">reader</span><span class=\"o\">.</span><span class=\"na\">read</span><span class=\"o\">(</span><span class=\"n\">buffer</span><span class=\"o\">)</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n      <span class=\"o\">}</span>\n      <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">String</span><span class=\"o\">(</span><span class=\"n\">buffer</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">io</span><span class=\"o\">.</span><span class=\"na\">IOException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n      <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n  <span class=\"o\">}</span>\n\n  <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">args</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n      <span class=\"k\">return</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"n\">String</span> <span class=\"n\">config</span> <span class=\"o\">=</span> <span class=\"n\">readConfigFromFile</span><span class=\"o\">(</span><span class=\"n\">args</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]);</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">config</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n      <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">err</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Can't read config from \"</span> <span class=\"o\">+</span> <span class=\"n\">args</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]);</span>\n      <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">exit</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">lines</span> <span class=\"o\">=</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"na\">split</span><span class=\"o\">(</span><span class=\"s\">\"\\n\"</span><span class=\"o\">);</span>\n    <span class=\"o\">...</span>\n  <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre></div>\n</td></tr></table>\n<h1 id=\"references\">References</h1>\n<div class=\"footnote\">\n<hr>\n<ol>\n<li id=\"fn-CWE\">\n<p>https://cwe.mitre.org/data/definitions/476.html\u00a0<a class=\"footnote-backref\" href=\"#fnref-CWE\" title=\"Jump back to footnote 1 in the text\">\u21a9</a></p>\n</li>\n<li id=\"fn-CERT1\">\n<p>https://wiki.sei.cmu.edu/confluence/display/c/EXP34-C.+Do+not+dereference+null+pointers\u00a0<a class=\"footnote-backref\" href=\"#fnref-CERT1\" title=\"Jump back to footnote 2 in the text\">\u21a9</a></p>\n</li>\n<li id=\"fn-CERT2\">\n<p>https://wiki.sei.cmu.edu/confluence/display/java/EXP00-J.+Do+not+ignore+values+returned+by+methods\u00a0<a class=\"footnote-backref\" href=\"#fnref-CERT2\" title=\"Jump back to footnote 3 in the text\">\u21a9</a></p>\n</li>\n</ol>\n</div>\n  </div>\n  ", "CaseList": [{"HashID": "0621f14c61e4bf521537c6f8f7ae2d78", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "b04b416d62a4b97067b43a02eb25c02b.h", "FileName": "libavfilter/bufferqueue.h", "Line": 90, "Tip": "Return <b>null</b> to caller", "SrcLines": [" * Return NULL if the queue has not enough buffers.", " */", "static inline AVFrame *ff_bufqueue_peek(struct FFBufQueue *queue,", "                                        unsigned index)", "{", "    return index < queue->available ? BUCKET(index) : NULL;", "}", "", "/**", " * Get the first buffer from the queue and remove it."], "SrcStart": 85}, {"FileMD5": "e33dccb7e637f4ef30c4f323af55ae5d.c", "FileName": "libavcodec/opusenc_psy.c", "Line": 90, "Tip": "Function <b>ff_bufqueue_peek</b> executes and stores the return value to <b>cur</b> (<b>cur</b> can be null)", "SrcLines": ["", "    for (ch = 0; ch < s->avctx->channels; ch++) {", "        const int lap_size = (1 << s->bsize_analysis);", "        for (i = 1; i <= FFMIN(lap_size, index); i++) {", "            const int offset = i*120;", "            AVFrame *cur = ff_bufqueue_peek(s->bufqueue, index - i);", "            memcpy(&s->scratch[offset], cur->extended_data[ch], cur->nb_samples*sizeof(float));", "        }", "        for (i = 0; i < lap_size; i++) {", "            const int offset = i*120 + lap_size;"], "SrcStart": 85}, {"FileMD5": "e33dccb7e637f4ef30c4f323af55ae5d.c", "FileName": "libavcodec/opusenc_psy.c", "Line": 91, "Tip": "Load value from <b>cur-&gt;nb_samples</b>", "SrcLines": ["    for (ch = 0; ch < s->avctx->channels; ch++) {", "        const int lap_size = (1 << s->bsize_analysis);", "        for (i = 1; i <= FFMIN(lap_size, index); i++) {", "            const int offset = i*120;", "            AVFrame *cur = ff_bufqueue_peek(s->bufqueue, index - i);", "            memcpy(&s->scratch[offset], cur->extended_data[ch], cur->nb_samples*sizeof(float));", "        }", "        for (i = 0; i < lap_size; i++) {", "            const int offset = i*120 + lap_size;", "            AVFrame *cur = ff_bufqueue_peek(s->bufqueue, index + i);"], "SrcStart": 86}], "Review": 80, "Time": 1629219860000, "DocID": "PE0001", "File": "libavcodec/opusenc_psy.c", "Line": 91}, {"HashID": "c466b3232b5a2fe981ec8c833f6c647c", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "b04b416d62a4b97067b43a02eb25c02b.h", "FileName": "libavfilter/bufferqueue.h", "Line": 90, "Tip": "Return <b>null</b> to caller", "SrcLines": [" * Return NULL if the queue has not enough buffers.", " */", "static inline AVFrame *ff_bufqueue_peek(struct FFBufQueue *queue,", "                                        unsigned index)", "{", "    return index < queue->available ? BUCKET(index) : NULL;", "}", "", "/**", " * Get the first buffer from the queue and remove it."], "SrcStart": 85}, {"FileMD5": "e33dccb7e637f4ef30c4f323af55ae5d.c", "FileName": "libavcodec/opusenc_psy.c", "Line": 95, "Tip": "Function <b>ff_bufqueue_peek</b> executes and stores the return value to <b>cur</b> (<b>cur</b> can be null)", "SrcLines": ["            AVFrame *cur = ff_bufqueue_peek(s->bufqueue, index - i);", "            memcpy(&s->scratch[offset], cur->extended_data[ch], cur->nb_samples*sizeof(float));", "        }", "        for (i = 0; i < lap_size; i++) {", "            const int offset = i*120 + lap_size;", "            AVFrame *cur = ff_bufqueue_peek(s->bufqueue, index + i);", "            memcpy(&s->scratch[offset], cur->extended_data[ch], cur->nb_samples*sizeof(float));", "        }", "", "        s->dsp->vector_fmul(s->scratch, s->scratch, s->window[s->bsize_analysis],"], "SrcStart": 90}, {"FileMD5": "e33dccb7e637f4ef30c4f323af55ae5d.c", "FileName": "libavcodec/opusenc_psy.c", "Line": 96, "Tip": "Load value from <b>cur-&gt;extended_data</b>", "SrcLines": ["            memcpy(&s->scratch[offset], cur->extended_data[ch], cur->nb_samples*sizeof(float));", "        }", "        for (i = 0; i < lap_size; i++) {", "            const int offset = i*120 + lap_size;", "            AVFrame *cur = ff_bufqueue_peek(s->bufqueue, index + i);", "            memcpy(&s->scratch[offset], cur->extended_data[ch], cur->nb_samples*sizeof(float));", "        }", "", "        s->dsp->vector_fmul(s->scratch, s->scratch, s->window[s->bsize_analysis],", "                            (OPUS_BLOCK_SIZE(s->bsize_analysis) << 1));"], "SrcStart": 91}], "Review": 80, "Time": 1629219860000, "DocID": "PE0001", "File": "libavcodec/opusenc_psy.c", "Line": 96}, {"HashID": "6d7c0d4632a5abc91b4e17555b32dfcd", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "7e69d33baeb7d35bd78528fe21180640.c", "FileName": "libavfilter/f_metadata.c", "Line": 265, "Tip": "Store <b>null</b> to <b>s-&gt;avio_context</b>", "SrcLines": ["        s->print = print_file;", "    } else {", "        s->print = print_log;", "    }", "", "    s->avio_context = NULL;", "    if (s->file_str) {", "        if (!strcmp(\"-\", s->file_str)) {", "            ret = avio_open(&s->avio_context, \"pipe:1\", AVIO_FLAG_WRITE);", "        } else {"], "SrcStart": 260}, {"FileMD5": "7e69d33baeb7d35bd78528fe21180640.c", "FileName": "libavfilter/f_metadata.c", "Line": 282, "Tip": "Load value from <b>s-&gt;avio_context</b>", "SrcLines": ["                   s->file_str, buf);", "            return ret;", "        }", "", "        if (s->direct)", "            s->avio_context->direct = AVIO_FLAG_DIRECT;", "    }", "", "    return 0;", "}"], "SrcStart": 277}, {"FileMD5": "7e69d33baeb7d35bd78528fe21180640.c", "FileName": "libavfilter/f_metadata.c", "Line": 282, "Tip": "Store <b>32768</b> to <b>s-&gt;avio_context-&gt;direct</b>", "SrcLines": ["                   s->file_str, buf);", "            return ret;", "        }", "", "        if (s->direct)", "            s->avio_context->direct = AVIO_FLAG_DIRECT;", "    }", "", "    return 0;", "}"], "SrcStart": 277}], "Review": 80, "Time": 1629219860000, "DocID": "PE0001", "File": "libavfilter/f_metadata.c", "Line": 282}, {"HashID": "b62f4aec2c1b374e7012bd125b0d66ca", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "d14766da37af90e60fb96aa3cbdc058f.c", "FileName": "libavfilter/framesync.c", "Line": 262, "Tip": "Store <b>null</b> to <b>rframe</b>", "SrcLines": ["    unsigned need_copy = 0, i;", "    int64_t pts_next;", "    int ret;", "", "    if (!fs->in[in].frame) {", "        *rframe = NULL;", "        return 0;", "    }", "    frame = fs->in[in].frame;", "    if (get) {"], "SrcStart": 257}, {"FileMD5": "d14766da37af90e60fb96aa3cbdc058f.c", "FileName": "libavfilter/framesync.c", "Line": 255, "Tip": "Program reaches the return point, modifying the value <b>*(rframe)</b> to null", "SrcLines": ["    fs->in[in].have_next  = 1;", "}", "", "int ff_framesync_get_frame(FFFrameSync *fs, unsigned in, AVFrame **rframe,", "                            unsigned get)", "{", "    AVFrame *frame;", "    unsigned need_copy = 0, i;", "    int64_t pts_next;", "    int ret;"], "SrcStart": 250}, {"FileMD5": "3feec83c295ea0b12c06a8df33660237.c", "FileName": "libavfilter/f_streamselect.c", "Line": 61, "Tip": "Function <b>ff_framesync_get_frame</b> modifies the value <b>in[i]</b> to null, where <b>&amp;(in[i])</b> is used as the 3rd parameter (<b>rframe</b>)", "SrcLines": ["    StreamSelectContext *s = fs->opaque;", "    AVFrame **in = s->frames;", "    int i, j, ret = 0, have_out = 0;", "", "    for (i = 0; i < ctx->nb_inputs; i++) {", "        if ((ret = ff_framesync_get_frame(&s->fs, i, &in[i], 0)) < 0)", "            return ret;", "    }", "", "    for (j = 0; j < ctx->nb_inputs; j++) {"], "SrcStart": 56}, {"FileMD5": "3feec83c295ea0b12c06a8df33660237.c", "FileName": "libavfilter/f_streamselect.c", "Line": 70, "Tip": "Load value from <b>in[i]</b>", "SrcLines": ["    for (j = 0; j < ctx->nb_inputs; j++) {", "        for (i = 0; i < s->nb_map; i++) {", "            if (s->map[i] == j) {", "                AVFrame *out;", "", "                if (s->is_audio && s->last_pts[j] == in[j]->pts &&", "                    ctx->outputs[i]->frame_count_in > 0)", "                    continue;", "                out = av_frame_clone(in[j]);", "                if (!out)"], "SrcStart": 65}, {"FileMD5": "3feec83c295ea0b12c06a8df33660237.c", "FileName": "libavfilter/f_streamselect.c", "Line": 70, "Tip": "Load value from <b>in[i]-&gt;pts</b>", "SrcLines": ["    for (j = 0; j < ctx->nb_inputs; j++) {", "        for (i = 0; i < s->nb_map; i++) {", "            if (s->map[i] == j) {", "                AVFrame *out;", "", "                if (s->is_audio && s->last_pts[j] == in[j]->pts &&", "                    ctx->outputs[i]->frame_count_in > 0)", "                    continue;", "                out = av_frame_clone(in[j]);", "                if (!out)"], "SrcStart": 65}], "Review": 80, "Time": 1629219860000, "DocID": "PE0001", "File": "libavfilter/f_streamselect.c", "Line": 70}, {"HashID": "e64428a2fe76579e36ab87ef5e7320e3", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "d14766da37af90e60fb96aa3cbdc058f.c", "FileName": "libavfilter/framesync.c", "Line": 262, "Tip": "Store <b>null</b> to <b>rframe</b>", "SrcLines": ["    unsigned need_copy = 0, i;", "    int64_t pts_next;", "    int ret;", "", "    if (!fs->in[in].frame) {", "        *rframe = NULL;", "        return 0;", "    }", "    frame = fs->in[in].frame;", "    if (get) {"], "SrcStart": 257}, {"FileMD5": "d14766da37af90e60fb96aa3cbdc058f.c", "FileName": "libavfilter/framesync.c", "Line": 255, "Tip": "Program reaches the return point, modifying the value <b>*(rframe)</b> to null", "SrcLines": ["    fs->in[in].have_next  = 1;", "}", "", "int ff_framesync_get_frame(FFFrameSync *fs, unsigned in, AVFrame **rframe,", "                            unsigned get)", "{", "    AVFrame *frame;", "    unsigned need_copy = 0, i;", "    int64_t pts_next;", "    int ret;"], "SrcStart": 250}, {"FileMD5": "3feec83c295ea0b12c06a8df33660237.c", "FileName": "libavfilter/f_streamselect.c", "Line": 61, "Tip": "Function <b>ff_framesync_get_frame</b> modifies the value <b>in[i]</b> to null, where <b>&amp;(in[i])</b> is used as the 3rd parameter (<b>rframe</b>)", "SrcLines": ["    StreamSelectContext *s = fs->opaque;", "    AVFrame **in = s->frames;", "    int i, j, ret = 0, have_out = 0;", "", "    for (i = 0; i < ctx->nb_inputs; i++) {", "        if ((ret = ff_framesync_get_frame(&s->fs, i, &in[i], 0)) < 0)", "            return ret;", "    }", "", "    for (j = 0; j < ctx->nb_inputs; j++) {"], "SrcStart": 56}, {"FileMD5": "3feec83c295ea0b12c06a8df33660237.c", "FileName": "libavfilter/f_streamselect.c", "Line": 78, "Tip": "Load value from <b>in[i]</b>", "SrcLines": ["                out = av_frame_clone(in[j]);", "                if (!out)", "                    return AVERROR(ENOMEM);", "", "                out->pts = av_rescale_q(s->fs.pts, s->fs.time_base, ctx->outputs[i]->time_base);", "                s->last_pts[j] = in[j]->pts;", "                ret = ff_filter_frame(ctx->outputs[i], out);", "                have_out = 1;", "                if (ret < 0)", "                    return ret;"], "SrcStart": 73}, {"FileMD5": "3feec83c295ea0b12c06a8df33660237.c", "FileName": "libavfilter/f_streamselect.c", "Line": 78, "Tip": "Load value from <b>in[i]-&gt;pts</b>", "SrcLines": ["                out = av_frame_clone(in[j]);", "                if (!out)", "                    return AVERROR(ENOMEM);", "", "                out->pts = av_rescale_q(s->fs.pts, s->fs.time_base, ctx->outputs[i]->time_base);", "                s->last_pts[j] = in[j]->pts;", "                ret = ff_filter_frame(ctx->outputs[i], out);", "                have_out = 1;", "                if (ret < 0)", "                    return ret;"], "SrcStart": 73}], "Review": 80, "Time": 1629219860000, "DocID": "PE0001", "File": "libavfilter/f_streamselect.c", "Line": 78}, {"HashID": "ab0274ca6200f02459b6a0a8b9d232a0", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "b04b416d62a4b97067b43a02eb25c02b.h", "FileName": "libavfilter/bufferqueue.h", "Line": 90, "Tip": "Return <b>null</b> to caller", "SrcLines": [" * Return NULL if the queue has not enough buffers.", " */", "static inline AVFrame *ff_bufqueue_peek(struct FFBufQueue *queue,", "                                        unsigned index)", "{", "    return index < queue->available ? BUCKET(index) : NULL;", "}", "", "/**", " * Get the first buffer from the queue and remove it."], "SrcStart": 85}, {"FileMD5": "ac5cb080ef5745c560187c4610091d19.c", "FileName": "libavfilter/vf_deflicker.c", "Line": 377, "Tip": "Store the return value of function <b>ff_bufqueue_peek</b> to <b>in</b>", "SrcLines": ["        ff_bufqueue_add(ctx, &s->q, buf);", "        s->available++;", "        return 0;", "    }", "", "    in = ff_bufqueue_peek(&s->q, 0);", "", "    out = ff_get_video_buffer(outlink, outlink->w, outlink->h);", "    if (!out) {", "        av_frame_free(&buf);"], "SrcStart": 372}, {"FileMD5": "ac5cb080ef5745c560187c4610091d19.c", "FileName": "libavfilter/vf_deflicker.c", "Line": 387, "Tip": "Load value from <b>in</b>", "SrcLines": ["        return AVERROR(ENOMEM);", "    }", "", "    s->get_factor(ctx, &f);", "    if (!s->bypass)", "        s->deflicker(ctx, in->data[0], in->linesize[0], out->data[0], out->linesize[0],", "                     outlink->w, outlink->h, f);", "    for (y = 1 - s->bypass; y < s->nb_planes; y++) {", "        av_image_copy_plane(out->data[y], out->linesize[y],", "                            in->data[y], in->linesize[y],"], "SrcStart": 382}, {"FileMD5": "ac5cb080ef5745c560187c4610091d19.c", "FileName": "libavfilter/vf_deflicker.c", "Line": 387, "Tip": "Load value from <b>in-&gt;linesize[0]</b>", "SrcLines": ["        return AVERROR(ENOMEM);", "    }", "", "    s->get_factor(ctx, &f);", "    if (!s->bypass)", "        s->deflicker(ctx, in->data[0], in->linesize[0], out->data[0], out->linesize[0],", "                     outlink->w, outlink->h, f);", "    for (y = 1 - s->bypass; y < s->nb_planes; y++) {", "        av_image_copy_plane(out->data[y], out->linesize[y],", "                            in->data[y], in->linesize[y],"], "SrcStart": 382}], "Review": 80, "Time": 1629219860000, "DocID": "PE0001", "File": "libavfilter/vf_deflicker.c", "Line": 387}, {"HashID": "14b0eba9732912282b341c00eb06864f", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "b04b416d62a4b97067b43a02eb25c02b.h", "FileName": "libavfilter/bufferqueue.h", "Line": 90, "Tip": "Return <b>null</b> to caller", "SrcLines": [" * Return NULL if the queue has not enough buffers.", " */", "static inline AVFrame *ff_bufqueue_peek(struct FFBufQueue *queue,", "                                        unsigned index)", "{", "    return index < queue->available ? BUCKET(index) : NULL;", "}", "", "/**", " * Get the first buffer from the queue and remove it."], "SrcStart": 85}, {"FileMD5": "ac5cb080ef5745c560187c4610091d19.c", "FileName": "libavfilter/vf_deflicker.c", "Line": 377, "Tip": "Store the return value of function <b>ff_bufqueue_peek</b> to <b>in</b>", "SrcLines": ["        ff_bufqueue_add(ctx, &s->q, buf);", "        s->available++;", "        return 0;", "    }", "", "    in = ff_bufqueue_peek(&s->q, 0);", "", "    out = ff_get_video_buffer(outlink, outlink->w, outlink->h);", "    if (!out) {", "        av_frame_free(&buf);"], "SrcStart": 372}, {"FileMD5": "ac5cb080ef5745c560187c4610091d19.c", "FileName": "libavfilter/vf_deflicker.c", "Line": 391, "Tip": "Load value from <b>in</b>", "SrcLines": ["    if (!s->bypass)", "        s->deflicker(ctx, in->data[0], in->linesize[0], out->data[0], out->linesize[0],", "                     outlink->w, outlink->h, f);", "    for (y = 1 - s->bypass; y < s->nb_planes; y++) {", "        av_image_copy_plane(out->data[y], out->linesize[y],", "                            in->data[y], in->linesize[y],", "                            s->planewidth[y] * (1 + (s->depth > 8)), s->planeheight[y]);", "    }", "", "    av_frame_copy_props(out, in);"], "SrcStart": 386}, {"FileMD5": "ac5cb080ef5745c560187c4610091d19.c", "FileName": "libavfilter/vf_deflicker.c", "Line": 391, "Tip": "Load value from <b>in-&gt;linesize[i]</b>", "SrcLines": ["    if (!s->bypass)", "        s->deflicker(ctx, in->data[0], in->linesize[0], out->data[0], out->linesize[0],", "                     outlink->w, outlink->h, f);", "    for (y = 1 - s->bypass; y < s->nb_planes; y++) {", "        av_image_copy_plane(out->data[y], out->linesize[y],", "                            in->data[y], in->linesize[y],", "                            s->planewidth[y] * (1 + (s->depth > 8)), s->planeheight[y]);", "    }", "", "    av_frame_copy_props(out, in);"], "SrcStart": 386}], "Review": 80, "Time": 1629219860000, "DocID": "PE0001", "File": "libavfilter/vf_deflicker.c", "Line": 391}, {"HashID": "b1afffa354b8ef976be08004a84710d5", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "d14766da37af90e60fb96aa3cbdc058f.c", "FileName": "libavfilter/framesync.c", "Line": 262, "Tip": "Store <b>null</b> to <b>rframe</b>", "SrcLines": ["    unsigned need_copy = 0, i;", "    int64_t pts_next;", "    int ret;", "", "    if (!fs->in[in].frame) {", "        *rframe = NULL;", "        return 0;", "    }", "    frame = fs->in[in].frame;", "    if (get) {"], "SrcStart": 257}, {"FileMD5": "d14766da37af90e60fb96aa3cbdc058f.c", "FileName": "libavfilter/framesync.c", "Line": 255, "Tip": "Program reaches the return point, modifying the value <b>*(rframe)</b> to null", "SrcLines": ["    fs->in[in].have_next  = 1;", "}", "", "int ff_framesync_get_frame(FFFrameSync *fs, unsigned in, AVFrame **rframe,", "                            unsigned get)", "{", "    AVFrame *frame;", "    unsigned need_copy = 0, i;", "    int64_t pts_next;", "    int ret;"], "SrcStart": 250}, {"FileMD5": "eb596524aa6bcd85ba647cb5fb5c169b.c", "FileName": "libavfilter/vf_hysteresis.c", "Line": 95, "Tip": "Function <b>ff_framesync_get_frame</b> modifies the value <b>base</b> to null, where <b>&amp;(base)</b> is used as the 3rd parameter (<b>rframe</b>)", "SrcLines": ["    HysteresisContext *s = fs->opaque;", "    AVFilterLink *outlink = ctx->outputs[0];", "    AVFrame *out, *base, *alt;", "    int ret;", "", "    if ((ret = ff_framesync_get_frame(&s->fs, 0, &base, 0)) < 0 ||", "        (ret = ff_framesync_get_frame(&s->fs, 1, &alt,  0)) < 0)", "        return ret;", "", "    if (ctx->is_disabled) {"], "SrcStart": 90}, {"FileMD5": "eb596524aa6bcd85ba647cb5fb5c169b.c", "FileName": "libavfilter/vf_hysteresis.c", "Line": 113, "Tip": "Load value from <b>base</b>", "SrcLines": ["            return AVERROR(ENOMEM);", "        av_frame_copy_props(out, base);", "", "        for (p = 0; p < s->nb_planes; p++) {", "            if (!((1 << p) & s->planes)) {", "                av_image_copy_plane(out->data[p], out->linesize[p], base->data[p], base->linesize[p],", "                                    s->width[p], s->height[p]);", "                continue;", "            } else {", "                int y;"], "SrcStart": 108}, {"FileMD5": "eb596524aa6bcd85ba647cb5fb5c169b.c", "FileName": "libavfilter/vf_hysteresis.c", "Line": 113, "Tip": "Load value from <b>base-&gt;data[i]</b>", "SrcLines": ["            return AVERROR(ENOMEM);", "        av_frame_copy_props(out, base);", "", "        for (p = 0; p < s->nb_planes; p++) {", "            if (!((1 << p) & s->planes)) {", "                av_image_copy_plane(out->data[p], out->linesize[p], base->data[p], base->linesize[p],", "                                    s->width[p], s->height[p]);", "                continue;", "            } else {", "                int y;"], "SrcStart": 108}], "Review": 80, "Time": 1629219860000, "DocID": "PE0001", "File": "libavfilter/vf_hysteresis.c", "Line": 113}, {"HashID": "60b9e16e43764983017b7f55b0fb2138", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "d14766da37af90e60fb96aa3cbdc058f.c", "FileName": "libavfilter/framesync.c", "Line": 262, "Tip": "Store <b>null</b> to <b>rframe</b>", "SrcLines": ["    unsigned need_copy = 0, i;", "    int64_t pts_next;", "    int ret;", "", "    if (!fs->in[in].frame) {", "        *rframe = NULL;", "        return 0;", "    }", "    frame = fs->in[in].frame;", "    if (get) {"], "SrcStart": 257}, {"FileMD5": "d14766da37af90e60fb96aa3cbdc058f.c", "FileName": "libavfilter/framesync.c", "Line": 255, "Tip": "Program reaches the return point, modifying the value <b>*(rframe)</b> to null", "SrcLines": ["    fs->in[in].have_next  = 1;", "}", "", "int ff_framesync_get_frame(FFFrameSync *fs, unsigned in, AVFrame **rframe,", "                            unsigned get)", "{", "    AVFrame *frame;", "    unsigned need_copy = 0, i;", "    int64_t pts_next;", "    int ret;"], "SrcStart": 250}, {"FileMD5": "eb596524aa6bcd85ba647cb5fb5c169b.c", "FileName": "libavfilter/vf_hysteresis.c", "Line": 95, "Tip": "Function <b>ff_framesync_get_frame</b> modifies the value <b>base</b> to null, where <b>&amp;(base)</b> is used as the 3rd parameter (<b>rframe</b>)", "SrcLines": ["    HysteresisContext *s = fs->opaque;", "    AVFilterLink *outlink = ctx->outputs[0];", "    AVFrame *out, *base, *alt;", "    int ret;", "", "    if ((ret = ff_framesync_get_frame(&s->fs, 0, &base, 0)) < 0 ||", "        (ret = ff_framesync_get_frame(&s->fs, 1, &alt,  0)) < 0)", "        return ret;", "", "    if (ctx->is_disabled) {"], "SrcStart": 90}, {"FileMD5": "eb596524aa6bcd85ba647cb5fb5c169b.c", "FileName": "libavfilter/vf_hysteresis.c", "Line": 128, "Tip": "Load value from <b>base</b>", "SrcLines": ["", "            s->index = -1;", "            memset(s->map, 0, s->width[0] * s->height[0]);", "            memset(s->xy, 0, s->width[0] * s->height[0] * 4);", "", "            s->hysteresis(s, base->data[p], alt->data[p],", "                          out->data[p],", "                          base->linesize[p], alt->linesize[p],", "                          out->linesize[p],", "                          s->width[p], s->height[p]);"], "SrcStart": 123}, {"FileMD5": "eb596524aa6bcd85ba647cb5fb5c169b.c", "FileName": "libavfilter/vf_hysteresis.c", "Line": 128, "Tip": "Load value from <b>base-&gt;data[i]</b>", "SrcLines": ["", "            s->index = -1;", "            memset(s->map, 0, s->width[0] * s->height[0]);", "            memset(s->xy, 0, s->width[0] * s->height[0] * 4);", "", "            s->hysteresis(s, base->data[p], alt->data[p],", "                          out->data[p],", "                          base->linesize[p], alt->linesize[p],", "                          out->linesize[p],", "                          s->width[p], s->height[p]);"], "SrcStart": 123}], "Review": 80, "Time": 1629219860000, "DocID": "PE0001", "File": "libavfilter/vf_hysteresis.c", "Line": 128}, {"HashID": "ed6a7780ca1d06a5e4073c62f9187a8a", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "d14766da37af90e60fb96aa3cbdc058f.c", "FileName": "libavfilter/framesync.c", "Line": 262, "Tip": "Store <b>null</b> to <b>rframe</b>", "SrcLines": ["    unsigned need_copy = 0, i;", "    int64_t pts_next;", "    int ret;", "", "    if (!fs->in[in].frame) {", "        *rframe = NULL;", "        return 0;", "    }", "    frame = fs->in[in].frame;", "    if (get) {"], "SrcStart": 257}, {"FileMD5": "d14766da37af90e60fb96aa3cbdc058f.c", "FileName": "libavfilter/framesync.c", "Line": 255, "Tip": "Program reaches the return point, modifying the value <b>*(rframe)</b> to null", "SrcLines": ["    fs->in[in].have_next  = 1;", "}", "", "int ff_framesync_get_frame(FFFrameSync *fs, unsigned in, AVFrame **rframe,", "                            unsigned get)", "{", "    AVFrame *frame;", "    unsigned need_copy = 0, i;", "    int64_t pts_next;", "    int ret;"], "SrcStart": 250}, {"FileMD5": "b646a1f4c89ef119b71d9495c51d9126.c", "FileName": "libavfilter/vf_midequalizer.c", "Line": 97, "Tip": "Function <b>ff_framesync_get_frame</b> modifies the value <b>in0</b> to null, where <b>&amp;(in0)</b> is used as the 3rd parameter (<b>rframe</b>)", "SrcLines": ["    MidEqualizerContext *s = fs->opaque;", "    AVFilterLink *outlink = ctx->outputs[0];", "    AVFrame *out, *in0, *in1;", "    int ret;", "", "    if ((ret = ff_framesync_get_frame(&s->fs, 0, &in0, 0)) < 0 ||", "        (ret = ff_framesync_get_frame(&s->fs, 1, &in1, 0)) < 0)", "        return ret;", "", "    if (ctx->is_disabled) {"], "SrcStart": 92}, {"FileMD5": "b646a1f4c89ef119b71d9495c51d9126.c", "FileName": "libavfilter/vf_midequalizer.c", "Line": 115, "Tip": "Load value from <b>in0</b>", "SrcLines": ["            return AVERROR(ENOMEM);", "        av_frame_copy_props(out, in0);", "", "        for (p = 0; p < s->nb_planes; p++) {", "            if (!((1 << p) & s->planes)) {", "                av_image_copy_plane(out->data[p], out->linesize[p], in0->data[p], in0->linesize[p],", "                                    s->width[0][p] * (1 + (s->histogram_size > 256)), s->height[0][p]);", "                continue;", "            }", ""], "SrcStart": 110}, {"FileMD5": "b646a1f4c89ef119b71d9495c51d9126.c", "FileName": "libavfilter/vf_midequalizer.c", "Line": 115, "Tip": "Load value from <b>in0-&gt;data[i]</b>", "SrcLines": ["            return AVERROR(ENOMEM);", "        av_frame_copy_props(out, in0);", "", "        for (p = 0; p < s->nb_planes; p++) {", "            if (!((1 << p) & s->planes)) {", "                av_image_copy_plane(out->data[p], out->linesize[p], in0->data[p], in0->linesize[p],", "                                    s->width[0][p] * (1 + (s->histogram_size > 256)), s->height[0][p]);", "                continue;", "            }", ""], "SrcStart": 110}], "Review": 80, "Time": 1629219860000, "DocID": "PE0001", "File": "libavfilter/vf_midequalizer.c", "Line": 115}]}, "start": 1, "end": 10, "page": 2, "total_pages": 9, "language": "en"}