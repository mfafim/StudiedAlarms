var data = {"bug_cases": {"BugType": "NULL pointer dereference", "Severity": 12, "CaseList": [{"HashID": "4d1778aaaa3b927ca06565180f47cc93", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "571459d78fd842f0d7505912ebf852dd.c", "FileName": "libavcodec/ccaption_dec.c", "Line": 408, "Tip": "Return <b>null</b> to caller", "SrcLines": ["        // use active screen", "        return ctx->screen + ctx->active_screen;", "    }", "    /* It was never an option */", "    return NULL;", "}", "", "static void roll_up(CCaptionSubContext *ctx)", "{", "    struct Screen *screen;"], "SrcStart": 403}, {"FileMD5": "571459d78fd842f0d7505912ebf852dd.c", "FileName": "libavcodec/ccaption_dec.c", "Line": 707, "Tip": "Function <b>get_writing_screen</b> executes and stores the return value to <b>screen</b> (<b>screen</b> can be null)", "SrcLines": ["    write_char(ctx, screen, 0);", "}", "", "static void handle_char(CCaptionSubContext *ctx, char hi, char lo)", "{", "    struct Screen *screen = get_writing_screen(ctx);", "", "    SET_FLAG(screen->row_used, ctx->cursor_row);", "", "    switch (hi) {"], "SrcStart": 702}, {"FileMD5": "571459d78fd842f0d7505912ebf852dd.c", "FileName": "libavcodec/ccaption_dec.c", "Line": 709, "Tip": "Load value from <b>screen-&gt;row_used</b>", "SrcLines": ["", "static void handle_char(CCaptionSubContext *ctx, char hi, char lo)", "{", "    struct Screen *screen = get_writing_screen(ctx);", "", "    SET_FLAG(screen->row_used, ctx->cursor_row);", "", "    switch (hi) {", "      case 0x11:", "        ctx->cursor_charset = CCSET_SPECIAL_AMERICAN;"], "SrcStart": 704}], "Review": 80, "Time": 1629219860000, "DocID": "PE0001", "File": "libavcodec/ccaption_dec.c", "Line": 709}, {"HashID": "a7147d2985d21fed012342d77f0056e2", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "670b183576993c3c13c65b254e3474b3.c", "FileName": "libavcodec/filter_units_bsf.c", "Line": 52, "Tip": "Store <b>null</b> to <b>list</b>", "SrcLines": ["", "static int filter_units_make_type_list(const char *list_string,", "                                       CodedBitstreamUnitType **type_list,", "                                       int *nb_types)", "{", "    CodedBitstreamUnitType *list = NULL;", "    int pass, count;", "", "    for (pass = 1; pass <= 2; pass++) {", "        long value, range_start, range_end;"], "SrcStart": 47}, {"FileMD5": "670b183576993c3c13c65b254e3474b3.c", "FileName": "libavcodec/filter_units_bsf.c", "Line": 75, "Tip": "Load value from <b>list</b>", "SrcLines": ["                if (str == value_end)", "                    goto invalid;", "", "                for (value = range_start; value < range_end; value++) {", "                    if (pass == 2)", "                        list[count] = value;", "                    ++count;", "                }", "            } else {", "                if (pass == 2)"], "SrcStart": 70}, {"FileMD5": "670b183576993c3c13c65b254e3474b3.c", "FileName": "libavcodec/filter_units_bsf.c", "Line": 75, "Tip": "Store <b>value</b> to <b>list[i]</b>", "SrcLines": ["                if (str == value_end)", "                    goto invalid;", "", "                for (value = range_start; value < range_end; value++) {", "                    if (pass == 2)", "                        list[count] = value;", "                    ++count;", "                }", "            } else {", "                if (pass == 2)"], "SrcStart": 70}], "Review": 80, "Time": 1629219860000, "DocID": "PE0001", "File": "libavcodec/filter_units_bsf.c", "Line": 75}, {"HashID": "0c95def98fb0424b6090f0629e0a613e", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "670b183576993c3c13c65b254e3474b3.c", "FileName": "libavcodec/filter_units_bsf.c", "Line": 52, "Tip": "Store <b>null</b> to <b>list</b>", "SrcLines": ["", "static int filter_units_make_type_list(const char *list_string,", "                                       CodedBitstreamUnitType **type_list,", "                                       int *nb_types)", "{", "    CodedBitstreamUnitType *list = NULL;", "    int pass, count;", "", "    for (pass = 1; pass <= 2; pass++) {", "        long value, range_start, range_end;"], "SrcStart": 47}, {"FileMD5": "670b183576993c3c13c65b254e3474b3.c", "FileName": "libavcodec/filter_units_bsf.c", "Line": 80, "Tip": "Load value from <b>list</b>", "SrcLines": ["                        list[count] = value;", "                    ++count;", "                }", "            } else {", "                if (pass == 2)", "                    list[count] = value;", "                ++count;", "            }", "            if (*str == '|')", "                ++str;"], "SrcStart": 75}, {"FileMD5": "670b183576993c3c13c65b254e3474b3.c", "FileName": "libavcodec/filter_units_bsf.c", "Line": 80, "Tip": "Store <b>value</b> to <b>list[count]</b>", "SrcLines": ["                        list[count] = value;", "                    ++count;", "                }", "            } else {", "                if (pass == 2)", "                    list[count] = value;", "                ++count;", "            }", "            if (*str == '|')", "                ++str;"], "SrcStart": 75}], "Review": 80, "Time": 1629219860000, "DocID": "PE0001", "File": "libavcodec/filter_units_bsf.c", "Line": 80}, {"HashID": "64cc842fa1610e034dafe5cfa28ae20e", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "4869fefdcd54ba97ec2a5823686ae963.h", "FileName": "libavcodec/get_bits.h", "Line": 628, "Tip": "Select the true branch at this point (<b>bit_size&lt;0</b> is true)", "SrcLines": ["                                   int bit_size, int is_le)", "{", "    int buffer_size;", "    int ret = 0;", "", "    if (bit_size >= INT_MAX - FFMAX(7, AV_INPUT_BUFFER_PADDING_SIZE*8) || bit_size < 0 || !buffer) {", "        bit_size    = 0;", "        buffer      = NULL;", "        ret         = AVERROR_INVALIDDATA;", "    }"], "SrcStart": 623}, {"FileMD5": "4869fefdcd54ba97ec2a5823686ae963.h", "FileName": "libavcodec/get_bits.h", "Line": 634, "Tip": "<b>null</b> assigned to <b>buffer</b> reaches here", "SrcLines": ["        bit_size    = 0;", "        buffer      = NULL;", "        ret         = AVERROR_INVALIDDATA;", "    }", "", "    buffer_size = (bit_size + 7) >> 3;", "", "    s->buffer             = buffer;", "    s->size_in_bits       = bit_size;", "    s->size_in_bits_plus8 = bit_size + 8;"], "SrcStart": 629}, {"FileMD5": "4869fefdcd54ba97ec2a5823686ae963.h", "FileName": "libavcodec/get_bits.h", "Line": 636, "Tip": "Store <b>null</b> to <b>s-&gt;buffer</b>", "SrcLines": ["        ret         = AVERROR_INVALIDDATA;", "    }", "", "    buffer_size = (bit_size + 7) >> 3;", "", "    s->buffer             = buffer;", "    s->size_in_bits       = bit_size;", "    s->size_in_bits_plus8 = bit_size + 8;", "    s->buffer_end         = buffer + buffer_size;", "    s->index              = 0;"], "SrcStart": 631}, {"FileMD5": "4869fefdcd54ba97ec2a5823686ae963.h", "FileName": "libavcodec/get_bits.h", "Line": 624, "Tip": "Program reaches the return point, modifying the value <b>s-&gt;buffer</b> to null", "SrcLines": ["    return bit;", "}", "", "static inline int init_get_bits_xe(GetBitContext *s, const uint8_t *buffer,", "                                   int bit_size, int is_le)", "{", "    int buffer_size;", "    int ret = 0;", "", "    if (bit_size >= INT_MAX - FFMAX(7, AV_INPUT_BUFFER_PADDING_SIZE*8) || bit_size < 0 || !buffer) {"], "SrcStart": 619}, {"FileMD5": "4869fefdcd54ba97ec2a5823686ae963.h", "FileName": "libavcodec/get_bits.h", "Line": 665, "Tip": "Function <b>init_get_bits_xe</b> modifies the value <b>s-&gt;buffer</b> to null, where <b>s</b> is used as the 1st parameter (<b>s</b>)", "SrcLines": ["                                int bit_size)", "{", "#ifdef BITSTREAM_READER_LE", "    return init_get_bits_xe(s, buffer, bit_size, 1);", "#else", "    return init_get_bits_xe(s, buffer, bit_size, 0);", "#endif", "}", "", "/**"], "SrcStart": 660}, {"FileMD5": "4869fefdcd54ba97ec2a5823686ae963.h", "FileName": "libavcodec/get_bits.h", "Line": 661, "Tip": "Program reaches the return point, modifying the value <b>s-&gt;buffer</b> to null", "SrcLines": [" * @param bit_size the size of the buffer in bits", " * @return 0 on success, AVERROR_INVALIDDATA if the buffer_size would overflow.", " */", "static inline int init_get_bits(GetBitContext *s, const uint8_t *buffer,", "                                int bit_size)", "{", "#ifdef BITSTREAM_READER_LE", "    return init_get_bits_xe(s, buffer, bit_size, 1);", "#else", "    return init_get_bits_xe(s, buffer, bit_size, 0);"], "SrcStart": 656}, {"FileMD5": "74ac5ed11551bfe1a22b52f285836220.c", "FileName": "libavcodec/mpegaudiodec_template.c", "Line": 1469, "Tip": "Function <b>init_get_bits</b> modifies the value <b>&amp;(s-&gt;gb)-&gt;buffer</b> to null, where <b>&amp;(s-&gt;gb)</b> is used as the 1st parameter (<b>s</b>)", "SrcLines": ["                           const uint8_t *buf, int buf_size)", "{", "    int i, nb_frames, ch, ret;", "    OUT_INT *samples_ptr;", "", "    init_get_bits(&s->gb, buf + HEADER_SIZE, (buf_size - HEADER_SIZE) * 8);", "    if (s->error_protection)", "        s->crc = get_bits(&s->gb, 16);", "", "    switch(s->layer) {"], "SrcStart": 1464}, {"FileMD5": "74ac5ed11551bfe1a22b52f285836220.c", "FileName": "libavcodec/mpegaudiodec_template.c", "Line": 1492, "Tip": "<b>&amp;(s-&gt;gb.buffer[get_bits_count(s-&gt;gb)&gt;&gt;3])</b> is used as the 2nd parameter in function <b>memmove</b> (<b>&amp;(s-&gt;gb.buffer[get_bits_count(s-&gt;gb)&gt;&gt;3])</b> can be null)", "SrcLines": ["        s->last_buf_size=0;", "        if (s->in_gb.buffer) {", "            align_get_bits(&s->gb);", "            i = (get_bits_left(&s->gb) >> 3) - s->extrasize;", "            if (i >= 0 && i <= BACKSTEP_SIZE) {", "                memmove(s->last_buf, s->gb.buffer + (get_bits_count(&s->gb) >> 3), i);", "                s->last_buf_size=i;", "            } else", "                av_log(s->avctx, AV_LOG_ERROR, \"invalid old backstep %d\\n\", i);", "            s->gb           = s->in_gb;"], "SrcStart": 1487}], "Review": 80, "Time": 1629219860000, "DocID": "PE0001", "File": "libavcodec/mpegaudiodec_template.c", "Line": 1492}, {"HashID": "80b0204eb9bfeba5a876aad9a4235a6b", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "4869fefdcd54ba97ec2a5823686ae963.h", "FileName": "libavcodec/get_bits.h", "Line": 628, "Tip": "Select the true branch at this point (<b>bit_size&lt;0</b> is true)", "SrcLines": ["                                   int bit_size, int is_le)", "{", "    int buffer_size;", "    int ret = 0;", "", "    if (bit_size >= INT_MAX - FFMAX(7, AV_INPUT_BUFFER_PADDING_SIZE*8) || bit_size < 0 || !buffer) {", "        bit_size    = 0;", "        buffer      = NULL;", "        ret         = AVERROR_INVALIDDATA;", "    }"], "SrcStart": 623}, {"FileMD5": "4869fefdcd54ba97ec2a5823686ae963.h", "FileName": "libavcodec/get_bits.h", "Line": 634, "Tip": "<b>null</b> assigned to <b>buffer</b> reaches here", "SrcLines": ["        bit_size    = 0;", "        buffer      = NULL;", "        ret         = AVERROR_INVALIDDATA;", "    }", "", "    buffer_size = (bit_size + 7) >> 3;", "", "    s->buffer             = buffer;", "    s->size_in_bits       = bit_size;", "    s->size_in_bits_plus8 = bit_size + 8;"], "SrcStart": 629}, {"FileMD5": "4869fefdcd54ba97ec2a5823686ae963.h", "FileName": "libavcodec/get_bits.h", "Line": 636, "Tip": "Store <b>null</b> to <b>s-&gt;buffer</b>", "SrcLines": ["        ret         = AVERROR_INVALIDDATA;", "    }", "", "    buffer_size = (bit_size + 7) >> 3;", "", "    s->buffer             = buffer;", "    s->size_in_bits       = bit_size;", "    s->size_in_bits_plus8 = bit_size + 8;", "    s->buffer_end         = buffer + buffer_size;", "    s->index              = 0;"], "SrcStart": 631}, {"FileMD5": "4869fefdcd54ba97ec2a5823686ae963.h", "FileName": "libavcodec/get_bits.h", "Line": 624, "Tip": "Program reaches the return point, modifying the value <b>s-&gt;buffer</b> to null", "SrcLines": ["    return bit;", "}", "", "static inline int init_get_bits_xe(GetBitContext *s, const uint8_t *buffer,", "                                   int bit_size, int is_le)", "{", "    int buffer_size;", "    int ret = 0;", "", "    if (bit_size >= INT_MAX - FFMAX(7, AV_INPUT_BUFFER_PADDING_SIZE*8) || bit_size < 0 || !buffer) {"], "SrcStart": 619}, {"FileMD5": "4869fefdcd54ba97ec2a5823686ae963.h", "FileName": "libavcodec/get_bits.h", "Line": 665, "Tip": "Function <b>init_get_bits_xe</b> modifies the value <b>s-&gt;buffer</b> to null, where <b>s</b> is used as the 1st parameter (<b>s</b>)", "SrcLines": ["                                int bit_size)", "{", "#ifdef BITSTREAM_READER_LE", "    return init_get_bits_xe(s, buffer, bit_size, 1);", "#else", "    return init_get_bits_xe(s, buffer, bit_size, 0);", "#endif", "}", "", "/**"], "SrcStart": 660}, {"FileMD5": "4869fefdcd54ba97ec2a5823686ae963.h", "FileName": "libavcodec/get_bits.h", "Line": 661, "Tip": "Program reaches the return point, modifying the value <b>s-&gt;buffer</b> to null", "SrcLines": [" * @param bit_size the size of the buffer in bits", " * @return 0 on success, AVERROR_INVALIDDATA if the buffer_size would overflow.", " */", "static inline int init_get_bits(GetBitContext *s, const uint8_t *buffer,", "                                int bit_size)", "{", "#ifdef BITSTREAM_READER_LE", "    return init_get_bits_xe(s, buffer, bit_size, 1);", "#else", "    return init_get_bits_xe(s, buffer, bit_size, 0);"], "SrcStart": 656}, {"FileMD5": "74ac5ed11551bfe1a22b52f285836220.c", "FileName": "libavcodec/mpegaudiodec_template.c", "Line": 1469, "Tip": "Function <b>init_get_bits</b> modifies the value <b>&amp;(s-&gt;gb)-&gt;buffer</b> to null, where <b>&amp;(s-&gt;gb)</b> is used as the 1st parameter (<b>s</b>)", "SrcLines": ["                           const uint8_t *buf, int buf_size)", "{", "    int i, nb_frames, ch, ret;", "    OUT_INT *samples_ptr;", "", "    init_get_bits(&s->gb, buf + HEADER_SIZE, (buf_size - HEADER_SIZE) * 8);", "    if (s->error_protection)", "        s->crc = get_bits(&s->gb, 16);", "", "    switch(s->layer) {"], "SrcStart": 1464}, {"FileMD5": "74ac5ed11551bfe1a22b52f285836220.c", "FileName": "libavcodec/mpegaudiodec_template.c", "Line": 1510, "Tip": "Copy data from <b>&amp;(s-&gt;gb.buffer[buf_size][-4][0-i])</b> (<b>&amp;(s-&gt;gb.buffer[buf_size][-4][0-i])</b> can be null)", "SrcLines": ["            if (i < 0)", "                av_log(s->avctx, AV_LOG_ERROR, \"invalid new backstep %d\\n\", i);", "            i = FFMIN(BACKSTEP_SIZE, buf_size - HEADER_SIZE);", "        }", "        av_assert1(i <= buf_size - HEADER_SIZE && i >= 0);", "        memcpy(s->last_buf + s->last_buf_size, s->gb.buffer + buf_size - HEADER_SIZE - i, i);", "        s->last_buf_size += i;", "    }", "", "    if(nb_frames < 0)"], "SrcStart": 1505}], "Review": 80, "Time": 1629219860000, "DocID": "PE0001", "File": "libavcodec/mpegaudiodec_template.c", "Line": 1510}, {"HashID": "0621f14c61e4bf521537c6f8f7ae2d78", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "b04b416d62a4b97067b43a02eb25c02b.h", "FileName": "libavfilter/bufferqueue.h", "Line": 90, "Tip": "Return <b>null</b> to caller", "SrcLines": [" * Return NULL if the queue has not enough buffers.", " */", "static inline AVFrame *ff_bufqueue_peek(struct FFBufQueue *queue,", "                                        unsigned index)", "{", "    return index < queue->available ? BUCKET(index) : NULL;", "}", "", "/**", " * Get the first buffer from the queue and remove it."], "SrcStart": 85}, {"FileMD5": "e33dccb7e637f4ef30c4f323af55ae5d.c", "FileName": "libavcodec/opusenc_psy.c", "Line": 90, "Tip": "Function <b>ff_bufqueue_peek</b> executes and stores the return value to <b>cur</b> (<b>cur</b> can be null)", "SrcLines": ["", "    for (ch = 0; ch < s->avctx->channels; ch++) {", "        const int lap_size = (1 << s->bsize_analysis);", "        for (i = 1; i <= FFMIN(lap_size, index); i++) {", "            const int offset = i*120;", "            AVFrame *cur = ff_bufqueue_peek(s->bufqueue, index - i);", "            memcpy(&s->scratch[offset], cur->extended_data[ch], cur->nb_samples*sizeof(float));", "        }", "        for (i = 0; i < lap_size; i++) {", "            const int offset = i*120 + lap_size;"], "SrcStart": 85}, {"FileMD5": "e33dccb7e637f4ef30c4f323af55ae5d.c", "FileName": "libavcodec/opusenc_psy.c", "Line": 91, "Tip": "Load value from <b>cur-&gt;nb_samples</b>", "SrcLines": ["    for (ch = 0; ch < s->avctx->channels; ch++) {", "        const int lap_size = (1 << s->bsize_analysis);", "        for (i = 1; i <= FFMIN(lap_size, index); i++) {", "            const int offset = i*120;", "            AVFrame *cur = ff_bufqueue_peek(s->bufqueue, index - i);", "            memcpy(&s->scratch[offset], cur->extended_data[ch], cur->nb_samples*sizeof(float));", "        }", "        for (i = 0; i < lap_size; i++) {", "            const int offset = i*120 + lap_size;", "            AVFrame *cur = ff_bufqueue_peek(s->bufqueue, index + i);"], "SrcStart": 86}], "Review": 80, "Time": 1629219860000, "DocID": "PE0001", "File": "libavcodec/opusenc_psy.c", "Line": 91}, {"HashID": "c466b3232b5a2fe981ec8c833f6c647c", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "b04b416d62a4b97067b43a02eb25c02b.h", "FileName": "libavfilter/bufferqueue.h", "Line": 90, "Tip": "Return <b>null</b> to caller", "SrcLines": [" * Return NULL if the queue has not enough buffers.", " */", "static inline AVFrame *ff_bufqueue_peek(struct FFBufQueue *queue,", "                                        unsigned index)", "{", "    return index < queue->available ? BUCKET(index) : NULL;", "}", "", "/**", " * Get the first buffer from the queue and remove it."], "SrcStart": 85}, {"FileMD5": "e33dccb7e637f4ef30c4f323af55ae5d.c", "FileName": "libavcodec/opusenc_psy.c", "Line": 95, "Tip": "Function <b>ff_bufqueue_peek</b> executes and stores the return value to <b>cur</b> (<b>cur</b> can be null)", "SrcLines": ["            AVFrame *cur = ff_bufqueue_peek(s->bufqueue, index - i);", "            memcpy(&s->scratch[offset], cur->extended_data[ch], cur->nb_samples*sizeof(float));", "        }", "        for (i = 0; i < lap_size; i++) {", "            const int offset = i*120 + lap_size;", "            AVFrame *cur = ff_bufqueue_peek(s->bufqueue, index + i);", "            memcpy(&s->scratch[offset], cur->extended_data[ch], cur->nb_samples*sizeof(float));", "        }", "", "        s->dsp->vector_fmul(s->scratch, s->scratch, s->window[s->bsize_analysis],"], "SrcStart": 90}, {"FileMD5": "e33dccb7e637f4ef30c4f323af55ae5d.c", "FileName": "libavcodec/opusenc_psy.c", "Line": 96, "Tip": "Load value from <b>cur-&gt;extended_data</b>", "SrcLines": ["            memcpy(&s->scratch[offset], cur->extended_data[ch], cur->nb_samples*sizeof(float));", "        }", "        for (i = 0; i < lap_size; i++) {", "            const int offset = i*120 + lap_size;", "            AVFrame *cur = ff_bufqueue_peek(s->bufqueue, index + i);", "            memcpy(&s->scratch[offset], cur->extended_data[ch], cur->nb_samples*sizeof(float));", "        }", "", "        s->dsp->vector_fmul(s->scratch, s->scratch, s->window[s->bsize_analysis],", "                            (OPUS_BLOCK_SIZE(s->bsize_analysis) << 1));"], "SrcStart": 91}], "Review": 80, "Time": 1629219860000, "DocID": "PE0001", "File": "libavcodec/opusenc_psy.c", "Line": 96}, {"HashID": "ee837d8c2140760b06b080c08145af63", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "2d7d4c1f04e49e38a8bb3d4d9c8199d1.c", "FileName": "libavcodec/rv34.c", "Line": 1636, "Tip": "Select the false branch at this point (<b>avctx-&gt;slice_count1==0</b> is false)", "SrcLines": ["            *got_picture_ptr = 1;", "        }", "        return 0;", "    }", "", "    if(!avctx->slice_count){", "        slice_count = (*buf++) + 1;", "        slices_hdr = buf + 4;", "        buf += 8 * slice_count;", "        buf_size -= 1 + 8 * slice_count;"], "SrcStart": 1631}, {"FileMD5": "2d7d4c1f04e49e38a8bb3d4d9c8199d1.c", "FileName": "libavcodec/rv34.c", "Line": 1644, "Tip": "<b>null</b> assigned to <b>slices_hdr</b> reaches here", "SrcLines": ["        buf += 8 * slice_count;", "        buf_size -= 1 + 8 * slice_count;", "    }else", "        slice_count = avctx->slice_count;", "", "    offset = get_slice_offset(avctx, slices_hdr, 0, slice_count, buf_size);", "    //parse first slice header to check whether this frame can be decoded", "    if(offset < 0 || offset > buf_size){", "        av_log(avctx, AV_LOG_ERROR, \"Slice offset is invalid\\n\");", "        return AVERROR_INVALIDDATA;"], "SrcStart": 1639}, {"FileMD5": "2d7d4c1f04e49e38a8bb3d4d9c8199d1.c", "FileName": "libavcodec/rv34.c", "Line": 1774, "Tip": "<b>null</b> is used as the 2nd parameter in function <b>get_slice_offset</b>", "SrcLines": ["", "        r->si.end = s->mb_width * s->mb_height;", "        s->mb_num_left = r->s.mb_x + r->s.mb_y*r->s.mb_width - r->si.start;", "", "        if(i+1 < slice_count){", "            int offset2 = get_slice_offset(avctx, slices_hdr, i+2, slice_count, buf_size);", "            if (offset2 < offset1 || offset2 > buf_size) {", "                av_log(avctx, AV_LOG_ERROR, \"Slice offset is invalid\\n\");", "                break;", "            }"], "SrcStart": 1769}, {"FileMD5": "2d7d4c1f04e49e38a8bb3d4d9c8199d1.c", "FileName": "libavcodec/rv34.c", "Line": 1561, "Tip": "Load value from <b>buf[n*8][-4]</b>", "SrcLines": ["", "static int get_slice_offset(AVCodecContext *avctx, const uint8_t *buf, int n, int slice_count, int buf_size)", "{", "    if (n < slice_count) {", "        if(avctx->slice_count) return avctx->slice_offset[n];", "        else                   return AV_RL32(buf + n*8 - 4) == 1 ? AV_RL32(buf + n*8) :  AV_RB32(buf + n*8);", "    } else", "        return buf_size;", "}", ""], "SrcStart": 1556}], "Review": 80, "Time": 1629219860000, "DocID": "PE0001", "File": "libavcodec/rv34.c", "Line": 1561}, {"HashID": "7b5f974f27a5fe6cdbc02e1137556b90", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "ce6bc1d93bbd272be441fb29ace60d36.c", "FileName": "libavcodec/sunrast.c", "Line": 133, "Tip": "Select the false branch at this point (<b>depth&lt;8</b> is false)", "SrcLines": ["            *(uint32_t *)ptr = (0xFFU<<24) + (buf[x]<<16) + (buf[len+x]<<8) + buf[len+len+x];", "    }", "", "    buf += maplength;", "", "    if (maplength && depth < 8) {", "        ptr = ptr2 = av_malloc_array((w + 15), h);", "        if (!ptr)", "            return AVERROR(ENOMEM);", "        stride = (w + 15 >> 3) * depth;"], "SrcStart": 128}, {"FileMD5": "ce6bc1d93bbd272be441fb29ace60d36.c", "FileName": "libavcodec/sunrast.c", "Line": 143, "Tip": "<b>null</b> assigned to <b>ptr_free</b> reaches here", "SrcLines": ["    } else {", "        ptr    = p->data[0];", "        stride = p->linesize[0];", "    }", "", "    if (type == RT_BYTE_ENCODED) {", "        int value, run;", "        uint8_t *end = ptr + h * stride;", "", "        x = 0;"], "SrcStart": 138}, {"FileMD5": "ce6bc1d93bbd272be441fb29ace60d36.c", "FileName": "libavcodec/sunrast.c", "Line": 178, "Tip": "Select the true branch at this point (<b>depth&lt;8</b> is true)", "SrcLines": ["            memcpy(ptr, buf, len);", "            ptr += stride;", "            buf += alen;", "        }", "    }", "    if (avctx->pix_fmt == AV_PIX_FMT_PAL8 && depth < 8) {", "        uint8_t *ptr_free = ptr2;", "        ptr = p->data[0];", "        for (y=0; y<h; y++) {", "            for (x = 0; x < (w + 7 >> 3) * depth; x++) {"], "SrcStart": 173}, {"FileMD5": "ce6bc1d93bbd272be441fb29ace60d36.c", "FileName": "libavcodec/sunrast.c", "Line": 182, "Tip": "Select the false branch at this point (<b>i!=(depth*((w+7)&gt;&gt;3))</b> is false)", "SrcLines": ["    }", "    if (avctx->pix_fmt == AV_PIX_FMT_PAL8 && depth < 8) {", "        uint8_t *ptr_free = ptr2;", "        ptr = p->data[0];", "        for (y=0; y<h; y++) {", "            for (x = 0; x < (w + 7 >> 3) * depth; x++) {", "                if (depth == 1) {", "                    ptr[8*x]   = ptr2[x] >> 7;", "                    ptr[8*x+1] = ptr2[x] >> 6 & 1;", "                    ptr[8*x+2] = ptr2[x] >> 5 & 1;"], "SrcStart": 177}, {"FileMD5": "ce6bc1d93bbd272be441fb29ace60d36.c", "FileName": "libavcodec/sunrast.c", "Line": 186, "Tip": "Load value from <b>ptr2[i]</b>", "SrcLines": ["        for (y=0; y<h; y++) {", "            for (x = 0; x < (w + 7 >> 3) * depth; x++) {", "                if (depth == 1) {", "                    ptr[8*x]   = ptr2[x] >> 7;", "                    ptr[8*x+1] = ptr2[x] >> 6 & 1;", "                    ptr[8*x+2] = ptr2[x] >> 5 & 1;", "                    ptr[8*x+3] = ptr2[x] >> 4 & 1;", "                    ptr[8*x+4] = ptr2[x] >> 3 & 1;", "                    ptr[8*x+5] = ptr2[x] >> 2 & 1;", "                    ptr[8*x+6] = ptr2[x] >> 1 & 1;"], "SrcStart": 181}], "Review": 80, "Time": 1629219860000, "DocID": "PE0001", "File": "libavcodec/sunrast.c", "Line": 186}, {"HashID": "b688f417c1d996e0888b52c823bd3520", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "6d0fcf2434c93bcd5e25f5832e4b05eb.c", "FileName": "libavfilter/af_afade.c", "Line": 475, "Tip": "Store <b>null</b> to <b>in</b>", "SrcLines": ["", "static int activate(AVFilterContext *ctx)", "{", "    AudioFadeContext *s   = ctx->priv;", "    AVFilterLink *outlink = ctx->outputs[0];", "    AVFrame *in = NULL, *out, *cf[2] = { NULL };", "    int ret = 0, nb_samples, status;", "    int64_t pts;", "", "    FF_FILTER_FORWARD_STATUS_BACK_ALL(outlink, ctx);"], "SrcStart": 470}, {"FileMD5": "6d0fcf2434c93bcd5e25f5832e4b05eb.c", "FileName": "libavfilter/af_afade.c", "Line": 510, "Tip": "Load value from <b>in</b>", "SrcLines": ["            if (ret < 0) {", "                return ret;", "            }", "        }", "        in->pts = s->pts;", "        s->pts += av_rescale_q(in->nb_samples,", "            (AVRational){ 1, outlink->sample_rate }, outlink->time_base);", "        return ff_filter_frame(outlink, in);", "    } else if (ff_inlink_queued_samples(ctx->inputs[0]) >= s->nb_samples &&", "               ff_inlink_queued_samples(ctx->inputs[1]) >= s->nb_samples && s->cf0_eof) {"], "SrcStart": 505}, {"FileMD5": "6d0fcf2434c93bcd5e25f5832e4b05eb.c", "FileName": "libavfilter/af_afade.c", "Line": 510, "Tip": "Load value from <b>in-&gt;nb_samples</b>", "SrcLines": ["            if (ret < 0) {", "                return ret;", "            }", "        }", "        in->pts = s->pts;", "        s->pts += av_rescale_q(in->nb_samples,", "            (AVRational){ 1, outlink->sample_rate }, outlink->time_base);", "        return ff_filter_frame(outlink, in);", "    } else if (ff_inlink_queued_samples(ctx->inputs[0]) >= s->nb_samples &&", "               ff_inlink_queued_samples(ctx->inputs[1]) >= s->nb_samples && s->cf0_eof) {"], "SrcStart": 505}], "Review": 80, "Time": 1629219860000, "DocID": "PE0001", "File": "libavfilter/af_afade.c", "Line": 510}]}, "start": 11, "end": 20, "page": 3, "total_pages": 8, "language": "en"}