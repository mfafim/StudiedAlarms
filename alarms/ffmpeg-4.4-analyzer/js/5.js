var data = {"bug_cases": {"BugType": "NULL pointer dereference", "Severity": 12, "CaseList": [{"HashID": "ab0274ca6200f02459b6a0a8b9d232a0", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "b04b416d62a4b97067b43a02eb25c02b.h", "FileName": "libavfilter/bufferqueue.h", "Line": 90, "Tip": "Return <b>null</b> to caller", "SrcLines": [" * Return NULL if the queue has not enough buffers.", " */", "static inline AVFrame *ff_bufqueue_peek(struct FFBufQueue *queue,", "                                        unsigned index)", "{", "    return index < queue->available ? BUCKET(index) : NULL;", "}", "", "/**", " * Get the first buffer from the queue and remove it."], "SrcStart": 85}, {"FileMD5": "ac5cb080ef5745c560187c4610091d19.c", "FileName": "libavfilter/vf_deflicker.c", "Line": 377, "Tip": "Store the return value of function <b>ff_bufqueue_peek</b> to <b>in</b>", "SrcLines": ["        ff_bufqueue_add(ctx, &s->q, buf);", "        s->available++;", "        return 0;", "    }", "", "    in = ff_bufqueue_peek(&s->q, 0);", "", "    out = ff_get_video_buffer(outlink, outlink->w, outlink->h);", "    if (!out) {", "        av_frame_free(&buf);"], "SrcStart": 372}, {"FileMD5": "ac5cb080ef5745c560187c4610091d19.c", "FileName": "libavfilter/vf_deflicker.c", "Line": 387, "Tip": "Load value from <b>in</b>", "SrcLines": ["        return AVERROR(ENOMEM);", "    }", "", "    s->get_factor(ctx, &f);", "    if (!s->bypass)", "        s->deflicker(ctx, in->data[0], in->linesize[0], out->data[0], out->linesize[0],", "                     outlink->w, outlink->h, f);", "    for (y = 1 - s->bypass; y < s->nb_planes; y++) {", "        av_image_copy_plane(out->data[y], out->linesize[y],", "                            in->data[y], in->linesize[y],"], "SrcStart": 382}, {"FileMD5": "ac5cb080ef5745c560187c4610091d19.c", "FileName": "libavfilter/vf_deflicker.c", "Line": 387, "Tip": "Load value from <b>in-&gt;linesize[0]</b>", "SrcLines": ["        return AVERROR(ENOMEM);", "    }", "", "    s->get_factor(ctx, &f);", "    if (!s->bypass)", "        s->deflicker(ctx, in->data[0], in->linesize[0], out->data[0], out->linesize[0],", "                     outlink->w, outlink->h, f);", "    for (y = 1 - s->bypass; y < s->nb_planes; y++) {", "        av_image_copy_plane(out->data[y], out->linesize[y],", "                            in->data[y], in->linesize[y],"], "SrcStart": 382}], "Review": 80, "Time": 1629219860000, "DocID": "PE0001", "File": "libavfilter/vf_deflicker.c", "Line": 387}, {"HashID": "14b0eba9732912282b341c00eb06864f", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "b04b416d62a4b97067b43a02eb25c02b.h", "FileName": "libavfilter/bufferqueue.h", "Line": 90, "Tip": "Return <b>null</b> to caller", "SrcLines": [" * Return NULL if the queue has not enough buffers.", " */", "static inline AVFrame *ff_bufqueue_peek(struct FFBufQueue *queue,", "                                        unsigned index)", "{", "    return index < queue->available ? BUCKET(index) : NULL;", "}", "", "/**", " * Get the first buffer from the queue and remove it."], "SrcStart": 85}, {"FileMD5": "ac5cb080ef5745c560187c4610091d19.c", "FileName": "libavfilter/vf_deflicker.c", "Line": 377, "Tip": "Store the return value of function <b>ff_bufqueue_peek</b> to <b>in</b>", "SrcLines": ["        ff_bufqueue_add(ctx, &s->q, buf);", "        s->available++;", "        return 0;", "    }", "", "    in = ff_bufqueue_peek(&s->q, 0);", "", "    out = ff_get_video_buffer(outlink, outlink->w, outlink->h);", "    if (!out) {", "        av_frame_free(&buf);"], "SrcStart": 372}, {"FileMD5": "ac5cb080ef5745c560187c4610091d19.c", "FileName": "libavfilter/vf_deflicker.c", "Line": 391, "Tip": "Load value from <b>in</b>", "SrcLines": ["    if (!s->bypass)", "        s->deflicker(ctx, in->data[0], in->linesize[0], out->data[0], out->linesize[0],", "                     outlink->w, outlink->h, f);", "    for (y = 1 - s->bypass; y < s->nb_planes; y++) {", "        av_image_copy_plane(out->data[y], out->linesize[y],", "                            in->data[y], in->linesize[y],", "                            s->planewidth[y] * (1 + (s->depth > 8)), s->planeheight[y]);", "    }", "", "    av_frame_copy_props(out, in);"], "SrcStart": 386}, {"FileMD5": "ac5cb080ef5745c560187c4610091d19.c", "FileName": "libavfilter/vf_deflicker.c", "Line": 391, "Tip": "Load value from <b>in-&gt;linesize[i]</b>", "SrcLines": ["    if (!s->bypass)", "        s->deflicker(ctx, in->data[0], in->linesize[0], out->data[0], out->linesize[0],", "                     outlink->w, outlink->h, f);", "    for (y = 1 - s->bypass; y < s->nb_planes; y++) {", "        av_image_copy_plane(out->data[y], out->linesize[y],", "                            in->data[y], in->linesize[y],", "                            s->planewidth[y] * (1 + (s->depth > 8)), s->planeheight[y]);", "    }", "", "    av_frame_copy_props(out, in);"], "SrcStart": 386}], "Review": 80, "Time": 1629219860000, "DocID": "PE0001", "File": "libavfilter/vf_deflicker.c", "Line": 391}, {"HashID": "b1afffa354b8ef976be08004a84710d5", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "d14766da37af90e60fb96aa3cbdc058f.c", "FileName": "libavfilter/framesync.c", "Line": 262, "Tip": "Store <b>null</b> to <b>rframe</b>", "SrcLines": ["    unsigned need_copy = 0, i;", "    int64_t pts_next;", "    int ret;", "", "    if (!fs->in[in].frame) {", "        *rframe = NULL;", "        return 0;", "    }", "    frame = fs->in[in].frame;", "    if (get) {"], "SrcStart": 257}, {"FileMD5": "d14766da37af90e60fb96aa3cbdc058f.c", "FileName": "libavfilter/framesync.c", "Line": 255, "Tip": "Program reaches the return point, modifying the value <b>*(rframe)</b> to null", "SrcLines": ["    fs->in[in].have_next  = 1;", "}", "", "int ff_framesync_get_frame(FFFrameSync *fs, unsigned in, AVFrame **rframe,", "                            unsigned get)", "{", "    AVFrame *frame;", "    unsigned need_copy = 0, i;", "    int64_t pts_next;", "    int ret;"], "SrcStart": 250}, {"FileMD5": "eb596524aa6bcd85ba647cb5fb5c169b.c", "FileName": "libavfilter/vf_hysteresis.c", "Line": 95, "Tip": "Function <b>ff_framesync_get_frame</b> modifies the value <b>base</b> to null, where <b>&amp;(base)</b> is used as the 3rd parameter (<b>rframe</b>)", "SrcLines": ["    HysteresisContext *s = fs->opaque;", "    AVFilterLink *outlink = ctx->outputs[0];", "    AVFrame *out, *base, *alt;", "    int ret;", "", "    if ((ret = ff_framesync_get_frame(&s->fs, 0, &base, 0)) < 0 ||", "        (ret = ff_framesync_get_frame(&s->fs, 1, &alt,  0)) < 0)", "        return ret;", "", "    if (ctx->is_disabled) {"], "SrcStart": 90}, {"FileMD5": "eb596524aa6bcd85ba647cb5fb5c169b.c", "FileName": "libavfilter/vf_hysteresis.c", "Line": 113, "Tip": "Load value from <b>base</b>", "SrcLines": ["            return AVERROR(ENOMEM);", "        av_frame_copy_props(out, base);", "", "        for (p = 0; p < s->nb_planes; p++) {", "            if (!((1 << p) & s->planes)) {", "                av_image_copy_plane(out->data[p], out->linesize[p], base->data[p], base->linesize[p],", "                                    s->width[p], s->height[p]);", "                continue;", "            } else {", "                int y;"], "SrcStart": 108}, {"FileMD5": "eb596524aa6bcd85ba647cb5fb5c169b.c", "FileName": "libavfilter/vf_hysteresis.c", "Line": 113, "Tip": "Load value from <b>base-&gt;data[i]</b>", "SrcLines": ["            return AVERROR(ENOMEM);", "        av_frame_copy_props(out, base);", "", "        for (p = 0; p < s->nb_planes; p++) {", "            if (!((1 << p) & s->planes)) {", "                av_image_copy_plane(out->data[p], out->linesize[p], base->data[p], base->linesize[p],", "                                    s->width[p], s->height[p]);", "                continue;", "            } else {", "                int y;"], "SrcStart": 108}], "Review": 80, "Time": 1629219860000, "DocID": "PE0001", "File": "libavfilter/vf_hysteresis.c", "Line": 113}, {"HashID": "60b9e16e43764983017b7f55b0fb2138", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "d14766da37af90e60fb96aa3cbdc058f.c", "FileName": "libavfilter/framesync.c", "Line": 262, "Tip": "Store <b>null</b> to <b>rframe</b>", "SrcLines": ["    unsigned need_copy = 0, i;", "    int64_t pts_next;", "    int ret;", "", "    if (!fs->in[in].frame) {", "        *rframe = NULL;", "        return 0;", "    }", "    frame = fs->in[in].frame;", "    if (get) {"], "SrcStart": 257}, {"FileMD5": "d14766da37af90e60fb96aa3cbdc058f.c", "FileName": "libavfilter/framesync.c", "Line": 255, "Tip": "Program reaches the return point, modifying the value <b>*(rframe)</b> to null", "SrcLines": ["    fs->in[in].have_next  = 1;", "}", "", "int ff_framesync_get_frame(FFFrameSync *fs, unsigned in, AVFrame **rframe,", "                            unsigned get)", "{", "    AVFrame *frame;", "    unsigned need_copy = 0, i;", "    int64_t pts_next;", "    int ret;"], "SrcStart": 250}, {"FileMD5": "eb596524aa6bcd85ba647cb5fb5c169b.c", "FileName": "libavfilter/vf_hysteresis.c", "Line": 95, "Tip": "Function <b>ff_framesync_get_frame</b> modifies the value <b>base</b> to null, where <b>&amp;(base)</b> is used as the 3rd parameter (<b>rframe</b>)", "SrcLines": ["    HysteresisContext *s = fs->opaque;", "    AVFilterLink *outlink = ctx->outputs[0];", "    AVFrame *out, *base, *alt;", "    int ret;", "", "    if ((ret = ff_framesync_get_frame(&s->fs, 0, &base, 0)) < 0 ||", "        (ret = ff_framesync_get_frame(&s->fs, 1, &alt,  0)) < 0)", "        return ret;", "", "    if (ctx->is_disabled) {"], "SrcStart": 90}, {"FileMD5": "eb596524aa6bcd85ba647cb5fb5c169b.c", "FileName": "libavfilter/vf_hysteresis.c", "Line": 128, "Tip": "Load value from <b>base</b>", "SrcLines": ["", "            s->index = -1;", "            memset(s->map, 0, s->width[0] * s->height[0]);", "            memset(s->xy, 0, s->width[0] * s->height[0] * 4);", "", "            s->hysteresis(s, base->data[p], alt->data[p],", "                          out->data[p],", "                          base->linesize[p], alt->linesize[p],", "                          out->linesize[p],", "                          s->width[p], s->height[p]);"], "SrcStart": 123}, {"FileMD5": "eb596524aa6bcd85ba647cb5fb5c169b.c", "FileName": "libavfilter/vf_hysteresis.c", "Line": 128, "Tip": "Load value from <b>base-&gt;data[i]</b>", "SrcLines": ["", "            s->index = -1;", "            memset(s->map, 0, s->width[0] * s->height[0]);", "            memset(s->xy, 0, s->width[0] * s->height[0] * 4);", "", "            s->hysteresis(s, base->data[p], alt->data[p],", "                          out->data[p],", "                          base->linesize[p], alt->linesize[p],", "                          out->linesize[p],", "                          s->width[p], s->height[p]);"], "SrcStart": 123}], "Review": 80, "Time": 1629219860000, "DocID": "PE0001", "File": "libavfilter/vf_hysteresis.c", "Line": 128}, {"HashID": "ed6a7780ca1d06a5e4073c62f9187a8a", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "d14766da37af90e60fb96aa3cbdc058f.c", "FileName": "libavfilter/framesync.c", "Line": 262, "Tip": "Store <b>null</b> to <b>rframe</b>", "SrcLines": ["    unsigned need_copy = 0, i;", "    int64_t pts_next;", "    int ret;", "", "    if (!fs->in[in].frame) {", "        *rframe = NULL;", "        return 0;", "    }", "    frame = fs->in[in].frame;", "    if (get) {"], "SrcStart": 257}, {"FileMD5": "d14766da37af90e60fb96aa3cbdc058f.c", "FileName": "libavfilter/framesync.c", "Line": 255, "Tip": "Program reaches the return point, modifying the value <b>*(rframe)</b> to null", "SrcLines": ["    fs->in[in].have_next  = 1;", "}", "", "int ff_framesync_get_frame(FFFrameSync *fs, unsigned in, AVFrame **rframe,", "                            unsigned get)", "{", "    AVFrame *frame;", "    unsigned need_copy = 0, i;", "    int64_t pts_next;", "    int ret;"], "SrcStart": 250}, {"FileMD5": "b646a1f4c89ef119b71d9495c51d9126.c", "FileName": "libavfilter/vf_midequalizer.c", "Line": 97, "Tip": "Function <b>ff_framesync_get_frame</b> modifies the value <b>in0</b> to null, where <b>&amp;(in0)</b> is used as the 3rd parameter (<b>rframe</b>)", "SrcLines": ["    MidEqualizerContext *s = fs->opaque;", "    AVFilterLink *outlink = ctx->outputs[0];", "    AVFrame *out, *in0, *in1;", "    int ret;", "", "    if ((ret = ff_framesync_get_frame(&s->fs, 0, &in0, 0)) < 0 ||", "        (ret = ff_framesync_get_frame(&s->fs, 1, &in1, 0)) < 0)", "        return ret;", "", "    if (ctx->is_disabled) {"], "SrcStart": 92}, {"FileMD5": "b646a1f4c89ef119b71d9495c51d9126.c", "FileName": "libavfilter/vf_midequalizer.c", "Line": 115, "Tip": "Load value from <b>in0</b>", "SrcLines": ["            return AVERROR(ENOMEM);", "        av_frame_copy_props(out, in0);", "", "        for (p = 0; p < s->nb_planes; p++) {", "            if (!((1 << p) & s->planes)) {", "                av_image_copy_plane(out->data[p], out->linesize[p], in0->data[p], in0->linesize[p],", "                                    s->width[0][p] * (1 + (s->histogram_size > 256)), s->height[0][p]);", "                continue;", "            }", ""], "SrcStart": 110}, {"FileMD5": "b646a1f4c89ef119b71d9495c51d9126.c", "FileName": "libavfilter/vf_midequalizer.c", "Line": 115, "Tip": "Load value from <b>in0-&gt;data[i]</b>", "SrcLines": ["            return AVERROR(ENOMEM);", "        av_frame_copy_props(out, in0);", "", "        for (p = 0; p < s->nb_planes; p++) {", "            if (!((1 << p) & s->planes)) {", "                av_image_copy_plane(out->data[p], out->linesize[p], in0->data[p], in0->linesize[p],", "                                    s->width[0][p] * (1 + (s->histogram_size > 256)), s->height[0][p]);", "                continue;", "            }", ""], "SrcStart": 110}], "Review": 80, "Time": 1629219860000, "DocID": "PE0001", "File": "libavfilter/vf_midequalizer.c", "Line": 115}, {"HashID": "b5031989db055c07a6e28e7f0b15b8cd", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "d14766da37af90e60fb96aa3cbdc058f.c", "FileName": "libavfilter/framesync.c", "Line": 262, "Tip": "Store <b>null</b> to <b>rframe</b>", "SrcLines": ["    unsigned need_copy = 0, i;", "    int64_t pts_next;", "    int ret;", "", "    if (!fs->in[in].frame) {", "        *rframe = NULL;", "        return 0;", "    }", "    frame = fs->in[in].frame;", "    if (get) {"], "SrcStart": 257}, {"FileMD5": "d14766da37af90e60fb96aa3cbdc058f.c", "FileName": "libavfilter/framesync.c", "Line": 255, "Tip": "Program reaches the return point, modifying the value <b>*(rframe)</b> to null", "SrcLines": ["    fs->in[in].have_next  = 1;", "}", "", "int ff_framesync_get_frame(FFFrameSync *fs, unsigned in, AVFrame **rframe,", "                            unsigned get)", "{", "    AVFrame *frame;", "    unsigned need_copy = 0, i;", "    int64_t pts_next;", "    int ret;"], "SrcStart": 250}, {"FileMD5": "b646a1f4c89ef119b71d9495c51d9126.c", "FileName": "libavfilter/vf_midequalizer.c", "Line": 98, "Tip": "Function <b>ff_framesync_get_frame</b> modifies the value <b>in1</b> to null, where <b>&amp;(in1)</b> is used as the 3rd parameter (<b>rframe</b>)", "SrcLines": ["    AVFilterLink *outlink = ctx->outputs[0];", "    AVFrame *out, *in0, *in1;", "    int ret;", "", "    if ((ret = ff_framesync_get_frame(&s->fs, 0, &in0, 0)) < 0 ||", "        (ret = ff_framesync_get_frame(&s->fs, 1, &in1, 0)) < 0)", "        return ret;", "", "    if (ctx->is_disabled) {", "        out = av_frame_clone(in0);"], "SrcStart": 93}, {"FileMD5": "b646a1f4c89ef119b71d9495c51d9126.c", "FileName": "libavfilter/vf_midequalizer.c", "Line": 120, "Tip": "Load value from <b>in1</b>", "SrcLines": ["                av_image_copy_plane(out->data[p], out->linesize[p], in0->data[p], in0->linesize[p],", "                                    s->width[0][p] * (1 + (s->histogram_size > 256)), s->height[0][p]);", "                continue;", "            }", "", "            s->midequalizer(in0->data[p], in1->data[p],", "                            out->data[p],", "                            in0->linesize[p], in1->linesize[p],", "                            out->linesize[p],", "                            s->width[0][p], s->height[0][p],"], "SrcStart": 115}, {"FileMD5": "b646a1f4c89ef119b71d9495c51d9126.c", "FileName": "libavfilter/vf_midequalizer.c", "Line": 120, "Tip": "Load value from <b>in1-&gt;data[i]</b>", "SrcLines": ["                av_image_copy_plane(out->data[p], out->linesize[p], in0->data[p], in0->linesize[p],", "                                    s->width[0][p] * (1 + (s->histogram_size > 256)), s->height[0][p]);", "                continue;", "            }", "", "            s->midequalizer(in0->data[p], in1->data[p],", "                            out->data[p],", "                            in0->linesize[p], in1->linesize[p],", "                            out->linesize[p],", "                            s->width[0][p], s->height[0][p],"], "SrcStart": 115}], "Review": 80, "Time": 1629219860000, "DocID": "PE0001", "File": "libavfilter/vf_midequalizer.c", "Line": 120}, {"HashID": "e5d1a3ad21e4578c0450afd8c5872726", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "d14766da37af90e60fb96aa3cbdc058f.c", "FileName": "libavfilter/framesync.c", "Line": 262, "Tip": "Store <b>null</b> to <b>rframe</b>", "SrcLines": ["    unsigned need_copy = 0, i;", "    int64_t pts_next;", "    int ret;", "", "    if (!fs->in[in].frame) {", "        *rframe = NULL;", "        return 0;", "    }", "    frame = fs->in[in].frame;", "    if (get) {"], "SrcStart": 257}, {"FileMD5": "d14766da37af90e60fb96aa3cbdc058f.c", "FileName": "libavfilter/framesync.c", "Line": 255, "Tip": "Program reaches the return point, modifying the value <b>*(rframe)</b> to null", "SrcLines": ["    fs->in[in].have_next  = 1;", "}", "", "int ff_framesync_get_frame(FFFrameSync *fs, unsigned in, AVFrame **rframe,", "                            unsigned get)", "{", "    AVFrame *frame;", "    unsigned need_copy = 0, i;", "    int64_t pts_next;", "    int ret;"], "SrcStart": 250}, {"FileMD5": "b646a1f4c89ef119b71d9495c51d9126.c", "FileName": "libavfilter/vf_midequalizer.c", "Line": 97, "Tip": "Function <b>ff_framesync_get_frame</b> modifies the value <b>in0</b> to null, where <b>&amp;(in0)</b> is used as the 3rd parameter (<b>rframe</b>)", "SrcLines": ["    MidEqualizerContext *s = fs->opaque;", "    AVFilterLink *outlink = ctx->outputs[0];", "    AVFrame *out, *in0, *in1;", "    int ret;", "", "    if ((ret = ff_framesync_get_frame(&s->fs, 0, &in0, 0)) < 0 ||", "        (ret = ff_framesync_get_frame(&s->fs, 1, &in1, 0)) < 0)", "        return ret;", "", "    if (ctx->is_disabled) {"], "SrcStart": 92}, {"FileMD5": "b646a1f4c89ef119b71d9495c51d9126.c", "FileName": "libavfilter/vf_midequalizer.c", "Line": 122, "Tip": "Load value from <b>in0</b>", "SrcLines": ["                continue;", "            }", "", "            s->midequalizer(in0->data[p], in1->data[p],", "                            out->data[p],", "                            in0->linesize[p], in1->linesize[p],", "                            out->linesize[p],", "                            s->width[0][p], s->height[0][p],", "                            s->width[1][p], s->height[1][p],", "                            s->histogram[0], s->histogram[1],"], "SrcStart": 117}, {"FileMD5": "b646a1f4c89ef119b71d9495c51d9126.c", "FileName": "libavfilter/vf_midequalizer.c", "Line": 122, "Tip": "Load value from <b>in0-&gt;linesize[i]</b>", "SrcLines": ["                continue;", "            }", "", "            s->midequalizer(in0->data[p], in1->data[p],", "                            out->data[p],", "                            in0->linesize[p], in1->linesize[p],", "                            out->linesize[p],", "                            s->width[0][p], s->height[0][p],", "                            s->width[1][p], s->height[1][p],", "                            s->histogram[0], s->histogram[1],"], "SrcStart": 117}], "Review": 80, "Time": 1629219860000, "DocID": "PE0001", "File": "libavfilter/vf_midequalizer.c", "Line": 122}, {"HashID": "d53919ebb7d433772dc5eb5836969221", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "5dc66c0497473dfb36694a5715c2f472.c", "FileName": "libavfilter/vf_tpad.c", "Line": 77, "Tip": "Store <b>null</b> to <b>frame</b>", "SrcLines": ["static int activate(AVFilterContext *ctx)", "{", "    AVFilterLink *inlink = ctx->inputs[0];", "    AVFilterLink *outlink = ctx->outputs[0];", "    TPadContext *s = ctx->priv;", "    AVFrame *frame = NULL;", "    int ret, status;", "    int64_t pts;", "", "    FF_FILTER_FORWARD_STATUS_BACK(outlink, inlink);"], "SrcStart": 72}, {"FileMD5": "5dc66c0497473dfb36694a5715c2f472.c", "FileName": "libavfilter/vf_tpad.c", "Line": 155, "Tip": "Load value from <b>frame</b>", "SrcLines": ["        } else if (s->stop_mode == 1) {", "            frame = av_frame_clone(s->cache_stop);", "            if (!frame)", "                return AVERROR(ENOMEM);", "        }", "        frame->pts = s->pts;", "        s->pts += av_rescale_q(1, av_inv_q(outlink->frame_rate), outlink->time_base);", "        if (s->pad_stop > 0)", "            s->pad_stop--;", "        return ff_filter_frame(outlink, frame);"], "SrcStart": 150}, {"FileMD5": "5dc66c0497473dfb36694a5715c2f472.c", "FileName": "libavfilter/vf_tpad.c", "Line": 155, "Tip": "Store <b>s-&gt;pts13</b> to <b>frame-&gt;pts</b>", "SrcLines": ["        } else if (s->stop_mode == 1) {", "            frame = av_frame_clone(s->cache_stop);", "            if (!frame)", "                return AVERROR(ENOMEM);", "        }", "        frame->pts = s->pts;", "        s->pts += av_rescale_q(1, av_inv_q(outlink->frame_rate), outlink->time_base);", "        if (s->pad_stop > 0)", "            s->pad_stop--;", "        return ff_filter_frame(outlink, frame);"], "SrcStart": 150}], "Review": 80, "Time": 1629219860000, "DocID": "PE0001", "File": "libavfilter/vf_tpad.c", "Line": 155}, {"HashID": "8030a0d1d1643b9ea24c1b9f13c45b38", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "b68b79d82e74ca6f2571feb9c97bd62e.c", "FileName": "libavformat/riffenc.c", "Line": 370, "Tip": "Return <b>null</b> to caller", "SrcLines": ["    for (i = 0; av_guid[i].id != AV_CODEC_ID_NONE; i++) {", "        if (id == av_guid[i].id)", "            return &(av_guid[i].guid);", "    }", "    return NULL;", "}"], "SrcStart": 365}, {"FileMD5": "b68b79d82e74ca6f2571feb9c97bd62e.c", "FileName": "libavformat/riffenc.c", "Line": 191, "Tip": "The return value of function <b>ff_get_codec_guid</b> is used as the 2nd parameter in function <b>ff_put_guid</b> (the return value of function <b>ff_get_codec_guid</b> can be null)", "SrcLines": ["        avio_wl16(pb, bps);", "        /* dwChannelMask */", "        avio_wl32(pb, write_channel_mask ? par->channel_layout : 0);", "        /* GUID + next 3 */", "        if (par->codec_id == AV_CODEC_ID_EAC3) {", "            ff_put_guid(pb, ff_get_codec_guid(par->codec_id, ff_codec_wav_guids));", "        } else {", "        avio_wl32(pb, par->codec_tag);", "        avio_wl32(pb, 0x00100000);", "        avio_wl32(pb, 0xAA000080);"], "SrcStart": 186}, {"FileMD5": "b68b79d82e74ca6f2571feb9c97bd62e.c", "FileName": "libavformat/riffenc.c", "Line": 359, "Tip": "<b>g</b> is used as the 2nd parameter in function <b>avio_write</b> (<b>g</b> can be null)", "SrcLines": ["}", "", "void ff_put_guid(AVIOContext *s, const ff_asf_guid *g)", "{", "    av_assert0(sizeof(*g) == 16);", "    avio_write(s, *g, sizeof(*g));", "}", "", "const ff_asf_guid *ff_get_codec_guid(enum AVCodecID id, const AVCodecGuid *av_guid)", "{"], "SrcStart": 354}, {"FileMD5": "9af674bc79383236b45bf624a2e9b936.c", "FileName": "libavformat/aviobuf.c", "Line": 227, "Tip": "Select the false branch at this point (<b>s-&gt;update_checksum==null</b> is false)", "SrcLines": ["    }", "}", "", "void avio_write(AVIOContext *s, const unsigned char *buf, int size)", "{", "    if (s->direct && !s->update_checksum) {", "        avio_flush(s);", "        writeout(s, buf, size);", "        return;", "    }"], "SrcStart": 222}, {"FileMD5": "9af674bc79383236b45bf624a2e9b936.c", "FileName": "libavformat/aviobuf.c", "Line": 234, "Tip": "Copy data from <b>buf</b> (<b>buf</b> can be null)", "SrcLines": ["        writeout(s, buf, size);", "        return;", "    }", "    while (size > 0) {", "        int len = FFMIN(s->buf_end - s->buf_ptr, size);", "        memcpy(s->buf_ptr, buf, len);", "        s->buf_ptr += len;", "", "        if (s->buf_ptr >= s->buf_end)", "            flush_buffer(s);"], "SrcStart": 229}], "Review": 80, "Time": 1629219860000, "DocID": "PE0001", "File": "libavformat/aviobuf.c", "Line": 234}, {"HashID": "88099194f53d12b3a71e2668817c4e79", "ReportChecker": "PSA NULL Pointer Dereference Checker", "Score": 60, "Steps": [{"FileMD5": "ad63f9dfb5602eaa310f9b5271628406.c", "FileName": "libavformat/id3v2.c", "Line": 824, "Tip": "Store <b>null</b> to <b>buffer</b>", "SrcLines": ["    int64_t next, end = avio_tell(pb) + len;", "    int taghdrlen;", "    const char *reason = NULL;", "    AVIOContext pb_local;", "    AVIOContext *pbx;", "    unsigned char *buffer = NULL;", "    int buffer_size       = 0;", "    const ID3v2EMFunc *extra_func = NULL;", "    unsigned char *uncompressed_buffer = NULL;", "    av_unused int uncompressed_buffer_size = 0;"], "SrcStart": 819}, {"FileMD5": "ad63f9dfb5602eaa310f9b5271628406.c", "FileName": "libavformat/id3v2.c", "Line": 976, "Tip": "<b>buffer</b> is used as the 2nd parameter in function <b>avio_read</b> (<b>buffer</b> can be null)", "SrcLines": ["            if (unsync || tunsync) {", "                uint8_t *b = buffer;", "                uint8_t *t = buffer;", "                uint8_t *end = t + tlen;", "", "                if (avio_read(pb, buffer, tlen) != tlen) {", "                    av_log(s, AV_LOG_ERROR, \"Failed to read tag data\\n\");", "                    goto seek;", "                }", ""], "SrcStart": 971}, {"FileMD5": "9af674bc79383236b45bf624a2e9b936.c", "FileName": "libavformat/aviobuf.c", "Line": 669, "Tip": "Copy data to <b>buf</b> (<b>buf</b> can be null)", "SrcLines": ["                len = s->buf_end - s->buf_ptr;", "                if (len == 0)", "                    break;", "            }", "        } else {", "            memcpy(buf, s->buf_ptr, len);", "            buf += len;", "            s->buf_ptr += len;", "            size -= len;", "        }"], "SrcStart": 664}], "Review": 80, "Time": 1629219860000, "DocID": "PE0001", "File": "libavformat/aviobuf.c", "Line": 669}]}, "start": 31, "end": 40, "page": 5, "total_pages": 8, "language": "en"}